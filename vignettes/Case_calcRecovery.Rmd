---
title: "Calculate recovery indicators"
author: "Wanda De Keersmaecker"
date: ""
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{Calculate recovery indicators}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
  ---
  
```{r setup, include=FALSE}
  knitr::opts_chunk$set(echo = TRUE, eval=F)
```
# General
This vignette calculates recovery indicators from pixels that experienced fire. It is assumed that a data cube with ARD (level2) Landsat (and/or S2) data has been built using FORCE. In addition a mask to select disturbed pixels that satisfy user-defined criteria (disturbed pixels have value 1; criteria include eg land during study period) and fire data (data have value 1 if a fire is present and a value 0 if no fire occurred) are present.

## Load required libraries
```{r}
library(raster)
library(UpscaleRecovery)
library(bfast)
library(strucchange)
library(lubridate)
library(terra)
library(rgdal)
```

## Inputs
The following inputs are needed:

- tempFun: how should observations be temporally aggregated? This can equal 'mean' or 'max'.
- temRes: the desired temporal resolution of the spectral data (this should equal the temporal resolution of the fire data)
- forcefolder: the full path to the folder where the data cube is stored
- l2folder: the subdirectory of the folder where the tile of interest is stored
- starttime: the start date of the study period
- endtime: the end date of the study period
- maxBreak: (only for recovery indicators derived from segmented time series): if maxbreak is true, the maximum break in the segmented series is used as disturbance date to calculate the recovery indicators. If maxbreak is false, the break closest to the provided disturbance timing is used to calculate recovery.
- inp: the preprocessing applied to the time series before computing the recovery indicators: segmented (for piecewise regression), smooth (time series smoothing using loess), or raw (no preprocessing)
- shortDenseTS: if FALSE, the recovery indicators follow closely the definitions given by Frazier et al.
- nPre: number of years prior to the disturbance that are used to derive the pre-disturbance condition
- nDist: number of observations used to derive the disturbance state
- nPostMin: start of the post-disturbance period: number of years after the disturbance
- nPostMax: end of the post-disturbance period: number of years after the disturbance
- h: h parameter of the breakpoints function in the strucchange package
- timeThres: only relevant for piecewise regression: threshold on the duration between the disturbance date and date of the detected break [years]
- seas: only relevant for piecewise regression: should a seasonality term be used?

```{r}
tempFun <- 'mean'
tempRes <- 'monthly'

forcefolder <- '/home/wanda/Documents/data/force/'
starttime <- c(1998,1,01)#start date: year, month, day
endtime <- c(2018,12,01)#end date: year, month, day
ext <- c(-43.38238361637443,-43.27938679020256,-4.555765244985907,-4.451717415449725)

# settings recovery indicators
recSet <- data.frame(maxBreak = c(F))
recSet$inp <- c('segmented')
recSet$shortDenseTS <- F
recSet$nPre <- c(2)
recSet$nDist <- c(1)
recSet$nPostMin <- c(4)
recSet$nPostMax <- c(6)
recSet$h <- c(0.15)
recSet$timeThres <- c(1)
recSet$seas <- c(T)
```

```{r folders}
# open folder structure
fldrs <- setFolders(forcefolder)
```

## Prepare optical data

- load spectral data
- calculate the Normalized Burn Ratio (NBR)
- mask low quality data
- mask pixels that are not of interest  
- create an image stack
- Temporal aggregation of data to ensure regular time steps
- ensure that the stack covers the time period of interest
```{r}
# get list of directories per continent that are present in the cube
continents <- file.path(fldrs[['l2folder']],c('n-america', 's-america', 'europe', 'asia', 'africa', 'oceania', 'antartica'))
continents <- continents[continents %in% list.dirs(fldrs[['l2folder']], recursive = F)]

obsvec <- c(12, 365, 1, 4)
names(obsvec) <- c('monthly', 'daily', 'annual', 'quart')
        

for(gi in 1:length(continents)){
  # get the tiles that overlap with the AOI
  elist <- getGrid(continents[gi], ext)
  # there should at least be one tile to process
  if (length(elist)>0){
    for(ti in 1:length(elist)){
      exti <- elist[[ti]]
      tilename <- names(elist)[ti]
      # folder with data of interest
      tilefolder <- file.path(continents[gi], tilename)
      # check if the tile folder of interest exists
      if(dir.exists(tilefolder)){
        # generate folder for temporary data of study area of interest
        extfolder <- file.path(forcefolder, 'temp', paste0('Area', exti[1],'_', exti[2],'_', exti[3],'_', exti[4]))
        if(!dir.exists(extfolder)){dir.create(extfolder)}
        # list available Bottom Of Atmosphere files
        img <- list.files(tilefolder,pattern = '*_BOA.tif')
        # extract the dates and sensors of the available data
        prts <- strsplit(img,'_')
        ldts <- as.Date(unlist(lapply(prts, '[[', 1)),'%Y%m%d')
        lsens <- unlist(lapply(prts, '[[', 3))
        fmask <- rast(file.path(tilefolder,'mask.tif'))
        rm(prts)
        
        # mask out area of the tile that is outside the area of interest
        fmask <- maskAOI(fmask,ext)
        # prepare each layer
        prepareNBRstack <- function(){
          for(i in 1:length(img)){# iterate over the BOA layers (each layer is associated with a particular date)
          # open image
          im <- rast(file.path(tilefolder,img[i]))# load the image with spectral data
          qaim <- rast(file.path(tilefolder,gsub("BOA", "QAI", img[i])))# load the Quality Assurance layer
          # calculate NBR
          nbri <- switch(1+ ((lsens[i] == 'SEN2A') | (lsens[i] == 'SEN2B')), calcNBR(im[[4]], im[[6]]), calcNBR(im[[8]], im[[10]])) 
          # mask low quality data
          nbrf <- mskQA(nbri, qaim, slope = c(0,1), aero = c(0,1))
          
          # resample S2 to the spatial resolution of Landsat
          if ((lsens[i] == 'SEN2A') | (lsens[i] == 'SEN2B')){
            nbrf <- terra::aggregate(nbrf, fact = 3, fun=mean)
          }
          # mask data using forest fire mask
          nbrf[fmask!=1] <- NA
          # add image to stack
          if(i == 1){
            st <- nbrf
          }else{
            st <- c(st, nbrf)
          }
          rm(nbri, nbrf, im, qaim)
        }
        # assign dates to stack
        names(st) <- ldts
        
        # generate a regular image stack
        tsbr <- calc(stack(fmask,st), function(x){toRegularTSStack(x, ldts, fun = tempFun, resol = tempRes)})#
        tres <- c('1 month', '3 months', '1 day', '1 year')
        names(tres) <- c('monthly', 'quarterly', 'daily', 'yearly')
        dtsbr <- seq(min(ldts), max(ldts), by = tres[tempRes])
        if(temRes == 'monthly'){
          dtsbr <- rollback(dtsbr, roll_to_first = TRUE, preserve_hms = TRUE)
        }
        
        # make sure that image stack covers time period of interest
        tsNBR <- setPeriod(br, starttime, endtime,tempRes, dtsbr)
        
        }
        
        tsNBR <- prepareNBRstack()
        
        # load fire data
        fimg <- list.files(tilefolder,'fire_X')
        tsf <- rast(file.path(tilefolder,fimg))
        # assign dates to stack
        dtsfr <- as.Date(fimg,'fire_X%Y_%m_%d.tif')
        names(tsf) <- dtsfr
        # make sure that image stack covers time period of interest
        tsFire <- setPeriod(tsf, starttime, endtime,tempRes, dtsfr)
        
        
        # combine mask, fire and nbr stacks into one stack 
        st <- c(fmask, tsFire, tsNBR) 
        
        # Calculate recovery indicators 
        # Three recovery indicators are computed: the RRI, R80P, and YrYr 
        for(i in 1:dim(recSet)[1]){# iterate over the settings to derive the recovery indicators 
          # get the correct number of observations per year 
          obspyr = obsvec[tempRes]
          # calculate the recovery indicators 
          out <- calc(st, function(x){calcRecoveryStack(x, maxBreak=recSet$maxBreak[i], 
                                                        obspyr=obspyr, 
                                                        inp = recSet$inp[i], 
                                                        shortDenseTS = recSet$shortDenseTS[i], 
                                                        nPre = recSet$nPre[i], 
                                                        nDist = recSet$nDist[i], 
                                                        nPostMin = recSet$nPostMin[i], 
                                                        nPostMax = recSet$nPostMax[i], 
                                                        h = recSet$h[i], 
                                                        timeThres = recSet$timeThres, 
                                                        seas = recSet$seas)}, 
                      filename = paste0(ofolder, tsfile, '_Stab_', tempRes, '_', 
                                        recSet$maxBreak[i],'_', 
                                        recSet$obspyr[i], '_',
                                        recSet$inp[i], '_', 
                                        recSet$shortDenseTS[i], '_',  
                                        recSet$nPre[i], '_', 
                                        recSet$nDist[i], '_', 
                                        recSet$nPostMin[i], '_' ,
                                        recSet$nPostMax[i], '_', 
                                        recSet$h[i]*100, '_', 
                                        recSet$timeThres[i], '_', 
                                        recSet$seas[i]),
                      overwrite=TRUE)
          
        }
        end_time_rec <- Sys.time()
        
      }
      
    }
  }
  # 
  
}

```

## Prepare the fire data

- load fire data
- make sure the data cover the time period of interest

```{r}

```

## Calculate recovery indicators
```{r}

```
