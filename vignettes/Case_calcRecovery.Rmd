---
title: "Calculate recovery indicators"
author: "Wanda De Keersmaecker"
date: ""
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{Calculate recovery indicators}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
  ---
  
```{r setup, include=FALSE}
  knitr::opts_chunk$set(echo = TRUE, eval=F)
```
# General
This vignette calculates recovery indicators from pixels that experienced fire. It is assumed that a data cube with ARD (level2) Landsat (and/or S2) data has been built using FORCE. In addition a mask to select disturbed pixels that satisfy user-defined criteria (disturbed pixels have value 1; criteria include eg land during study period) and fire data (data have value 1 if a fire is present and a value 0 if no fire occurred) are present.

## Load required libraries
```{r}
library(raster)
library(UpscaleRecovery)
library(bfast)
library(strucchange)
library(lubridate)
```

## Inputs
The following inputs are needed:

- tempFun: how should observations be temporally aggregated? This can equal 'mean' or 'max'.
- temRes: the desired temporal resolution of the spectral data (this should equal the temporal resolution of the fire data)
- forcefolder: the full path to the folder where the data cube is stored
- l2folder: the subdirectory of the folder where the tile of interest is stored
- starttime: the start date of the study period
- endtime: the end date of the study period
- maxBreak: (only for recovery indicators derived from segmented time series): if maxbreak is true, the maximum break in the segmented series is used as disturbance date to calculate the recovery indicators. If maxbreak is false, the break closest to the provided disturbance timing is used to calculate recovery.
- inp: the preprocessing applied to the time series before computing the recovery indicators: segmented (for piecewise regression), smooth (time series smoothing using loess), or raw (no preprocessing)
- shortDenseTS: if FALSE, the recovery indicators follow closely the definitions given by Frazier et al.
- nPre: number of years prior to the disturbance that are used to derive the pre-disturbance condition
- nDist: number of observations used to derive the disturbance state
- nPostMin: start of the post-disturbance period: number of years after the disturbance
- nPostMax: end of the post-disturbance period: number of years after the disturbance
- h: h parameter of the breakpoints function in the strucchange package
- timeThres: only relevant for piecewise regression: threshold on the duration between the disturbance date and date of the detected break [years]
- seas: only relevant for piecewise regression: should a seasonality term be used?

```{r}
tempFun <- 'mean'
tempRes <- 'monthly'
forcefolder <- '/home/wanda/Documents/data/force/'
l2folder <- 'level2/s-america/X0058_Y0025/'
starttime <- c(1998,1,01)#start date: year, month, day
endtime <- c(2018,12,01)#end date: year, month, day

# settings recovery indicators

recSet <- data.frame(maxBreak = c(F))
recSet$inp <- c('segmented')
recSet$shortDenseTS <- F
recSet$nPre <- c(2)
recSet$nDist <- c(1)
recSet$nPostMin <- c(4)
recSet$nPostMax <- c(6)
recSet$h <- c(0.15)
recSet$timeThres <- c(1)
recSet$seas <- c(T)

```

## Prepare optical data

- load spectral data
- calculate the Normalized Burn Ratio (NBR)
- mask low quality data
- mask pixels that are not of interest  
- create an image stack
- Temporal aggregation of data to ensure regular time steps
- ensure that the stack covers the time period of interest
```{r}
# list available Bottom Of Atmosphere files
img <- list.files(file.path(forcefolder,l2folder),'*_BOA.tif')

# extract the dates and sensors of the available data
prts <- strsplit(img,'_')
ldts <- as.Date(unlist(lapply(prts, '[[', 1)),'%Y%m%d')
lsens <- unlist(lapply(prts, '[[', 3))
fmask <- raster(file.path(forcefolder,l2folder,'mask.tif'))
rm(prts)

# 
for(i in 1:length(img)){
  # open image
  im <- stack(file.path(forcefolder,l2folder,img[i]))# load the image with spectral data
  qaim <- raster(file.path(forcefolder,l2folder,gsub("BOA", "QAI", img[i])))# load the Quality Assurance layer
  # calculate NBR
  nbri <- switch(1+ ((lsens[i] == 'SEN2A') | (lsens[i] == 'SEN2B')), calcNBR(im[[4]], im[[6]]), calcNBR(im[[8]], im[[10]])) 
  # mask low quality data
  nbrf <- mskQA(nbri, qaim, slope = c(0,1), aero = c(0,1))
  # mask data using forest fire mask
  nbrf[fmask!=1] <- NA
  # add image to stack
  if(i == 1){
    st <- nbrf
  }else{
    st <- addLayer(st, nbrf)
  }
  rm(nbri, nbrf, im, qaim)
}
# assign dates to stack
names(st) <- ldts

# generate a regular image stack
tsbr <- calc(stack(fmask,st), function(x){toRegularTSStack(x, ldts, fun = tempFun, resol = tempRes)})#
tres <- c('1 month', '3 months', '1 day', '1 year')
names(tres) <- c('monthly', 'quarterly', 'daily', 'yearly')
dtsbr <- seq(min(ldts), max(ldts), by = tres[tempRes])
if(temRes == 'monthly'){
  dtsbr <- rollback(dtsbr, roll_to_first = TRUE, preserve_hms = TRUE)
}

# make sure that image stack covers time period of interest
tsNBR <- setPeriod(br, starttime, endtime,tempRes, dtsbr)
```

## Prepare the fire data

- load fire data
- make sure the data cover the time period of interest

```{r}
# load fire data
fimg <- list.files(file.path(forcefolder,l2folder),'fire_X')
tsf <- stack(file.path(forcefolder,l2folder,fimg))
# assign dates to stack
dtsfr <- as.Date(fimg,'fire_X%Y_%m_%d.tif')
names(tsf) <- dtsfr
# make sure that image stack covers time period of interest
tsFire <- setPeriod(tsf, starttime, endtime,tempRes, dtsfr)
```

## Calculate recovery indicators
```{r}
# combine mask, fire and nbr stacks into one stack 
 st <- stack(fmask, tsFire, tsNBR) 
 obsvec <- c(12, 365, 1, 4)
 names(obsvec) <- c('monthly', 'daily', 'annual', 'quart')
 
# Calculate recovery indicators 
# Three recovery indicators are computed: the RRI, R80P, and YrYr 
for(i in 1:dim(recSet)[1]){# iterate over the settings to derive the recovery indicators 
  # get the correct number of observations per year 
  obspyr = obsvec[tempRes]
  # calculate the recovery indicators 
  out <- calc(st, function(x){calcRecoveryStack(x, maxBreak=recSet$maxBreak[i], 
                                                obspyr=obspyr, 
                                                inp = recSet$inp[i], 
                                                shortDenseTS = recSet$shortDenseTS[i], 
                                                nPre = recSet$nPre[i], 
                                                nDist = recSet$nDist[i], 
                                                nPostMin = recSet$nPostMin[i], 
                                                nPostMax = recSet$nPostMax[i], 
                                                h = recSet$h[i], 
                                                timeThres = recSet$timeThres, 
                                                seas = recSet$seas)}, 
              filename = paste0(ofolder, tsfile, '_Stab_', tempRes, '_', 
                                recSet$maxBreak[i],'_', 
                                recSet$obspyr[i], '_',
                                recSet$inp[i], '_', 
                                recSet$shortDenseTS[i], '_',  
                                recSet$nPre[i], '_', 
                                recSet$nDist[i], '_', 
                                recSet$nPostMin[i], '_' ,
                                recSet$nPostMax[i], '_', 
                                recSet$h[i]*100, '_', 
                                recSet$timeThres[i], '_', 
                                recSet$seas[i]),
              overwrite=TRUE)

}
end_time_rec <- Sys.time()

```