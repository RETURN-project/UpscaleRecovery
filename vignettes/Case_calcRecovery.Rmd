---
title: "Calculate recovery indicators"
author: "Wanda De Keersmaecker"
date: ""
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{Calculate recovery indicators}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
  ---
  
```{r setup, include=FALSE}
  knitr::opts_chunk$set(echo = TRUE, eval=F)
```
# General
This vignette calculates recovery indicators from pixels that experienced fire. It is assumed that a data cube with ARD (level2) Landsat (and/or S2) data has been built using FORCE. In addition a mask to select disturbed pixels that satisfy user-defined criteria (disturbed pixels have value 1; criteria include eg land during study period) and fire data (data have value 1 if a fire is present and a value 0 if no fire occurred) are present.

## Load required libraries
```{r}
library(raster)
library(UpscaleRecovery)
```

## Inputs
The following inputs are needed:

- tempFun: how should observations be temporally aggregated? This can equal 'mean' or 'max'.
- temRes: the desired temporal resolution of the spectral data (this should equal the temporal resolution of the fire data)
- forcefolder: the full path to the folder where the data cube is stored
- l2folder: the subdirectory of the folder where the tile of interest is stored
- starttime: the start date of the study period
- endtime: the end date of the study period
```{r}
tempFun <- 'mean'
tempRes <- 'monthly'
forcefolder <- '/home/wanda/Documents/data/force/'
l2folder <- 'level2/s-america/X0058_Y0025/'
starttime <- c(1998,1,01)#start date: year, month, day
endtime <- c(2018,12,01)#end date: year, month, day
```

## Prepare optical data

- load spectral data
- calculate the Normalized Burn Ratio (NBR)
- mask low quality data
- mask pixels that are not of interest  
- create an image stack
- Temporal aggregation of data to ensure regular time steps
- ensure that the stack covers the time period of interest
```{r}
# list available Bottom Of Atmosphere files
img <- list.files(file.path(forcefolder,l2folder),'*_BOA.tif')

# extract the dates and sensors of the available data
prts <- strsplit(img,'_')
ldts <- as.Date(unlist(lapply(prts, '[[', 1)),'%Y%m%d')
lsens <- unlist(lapply(prts, '[[', 3))
fmask <- raster(file.path(forcefolder,l2folder,'mask.tif'))
rm(prts)

# 
for(i in 1:length(img)){
  # open image
  im <- stack(file.path(forcefolder,l2folder,img[i]))# load the image with spectral data
  qaim <- raster(file.path(forcefolder,l2folder,gsub("BOA", "QAI", img[i])))# load the Quality Assurance layer
  # calculate NBR
  nbri <- switch(1+ ((lsens[i] == 'SEN2A') | (lsens[i] == 'SEN2B')), calcNBR(im[[4]], im[[6]]), calcNBR(im[[8]], im[[10]])) 
  # mask low quality data
  nbrf <- mskQA(nbri, qaim, slope = c(0,1), aero = c(0,1))
  # mask data using forest fire mask
  nbrf[fmask!=1] <- NA
  # add image to stack
  if(i == 1){
    st <- nbrf
  }else{
    st <- addLayer(st, nbrf)
  }
  rm(nbri, nbrf, im, qaim)
}
# assign dates to stack
names(st) <- ldts

# generate a regular image stack
tsbr <- calc(stack(fmask,st), function(x){toRegularTSStack(x, ldts, fun = tempFun, resol = tempRes)})#
tres <- c('1 month', '3 months', '1 day', '1 year')
names(tres) <- c('monthly', 'quarterly', 'daily', 'yearly')
dtsbr <- seq(min(ldts), max(ldts), by = tres[tempRes])
if(temRes == 'monthly'){
  dtsbr <- rollback(dtsbr, roll_to_first = TRUE, preserve_hms = TRUE)
}

# make sure that image stack covers time period of interest
tsNBR <- setPeriod(br, starttime, endtime,tempRes, dtsbr)
```

## Prepare the fire data

- load fire data
- make sure the data cover the time period of interest

```{r}
# load fire data
fimg <- list.files(file.path(forcefolder,l2folder),'fire_X')
tsf <- stack(file.path(forcefolder,l2folder,fimg))
# assign dates to stack
dtsfr <- as.Date(fimg,'fire_X%Y_%m_%d.tif')
names(tsf) <- dtsfr
# make sure that image stack covers time period of interest
tsFire <- setPeriod(tsf, starttime, endtime,tempRes, dtsfr)
```

## Calculate recovery indicators
```{r}
# combine mask, fire and nbr stacks into one stack 
 st <- stack(fmask, tsFire, tsNBR) 

# Calculate recovery indicators 
# Three recovery indicators are computed: the RRI, R80P, and YrYr 
for(i in 1:length(funSet[[1]])){# iterate over the settings to derive the recovery indicators 
  # get the correct number of observations per year 
  if(tempRes == 'monthly') { 
    obspyr = 12} else if(tempRes == 'daily'){obspyr = 365}else if(tempRes == 'annual'){obspyr = 1} 
  # calculate the recovery indicators 
  out <- calc(st, function(x){calcRecoveryStack(x, maxBreak=F, obspyr=obspyr, inp = funSet$input[i], shortDenseTS =
                                                  funSet$shortDenseTS[i], nPre = funSet$nPre[i], nDist =
                                                  funSet$nDist[i], nPostMin = funSet$nPostMin[i], 
                                                nPostMax = funSet$nPostMax[i], h = funSet$h[i], timeThres, slpThres)}, 
              filename = paste0(ofolder, tsfile, '_Stab_', tempRes, '_maxBreak_F', '_obspyr_', obspyr, '_inp_',
                                funSet$input[i], '_shortDenseTS_', funSet$shortDenseTS[i], '_nPre_',  funSet$nPre[i],
                                '_nDist_', funSet$nDist[i], '_nPostMin_', funSet$nPostMin[i], '_nPostMax_' ,
                                funSet$nPostMax[i], '_h_', funSet$h[i]*100, '_', timeThres, '_', slpThres),
              overwrite=TRUE)
}

```

