---
title: "Calculate recovery indicators"
author: "Wanda De Keersmaecker"
date: ""
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{Calculate recovery indicators}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
  ---
  
```{r setup, include=FALSE}
  knitr::opts_chunk$set(echo = TRUE, eval=F)
```

# Load required libraries
```{r}
library(raster)
library(ff)
library(UpscaleRecovery)
library(bfast)
library(strucchange)
library(lubridate)
```

# Inputs
 settings of the derived recovery indicators:

 - input: refers to the tine series pre-processing: raw (=no preprocessing), smoothed or segmented
 - h: This parameter defines the minimal segment size either given as fraction relative to the sample size or as an integer giving the minimal number of observations in each segment.
 - shortDenseTS: TRUE or FALSE. In case TRUE, the metrics are adjusted to be compatible with short, dense time series. In case FALSE, the input time series is assumed to have annual observations and at least 2 and 5 pre- and post-disturbance years, respectively.
 - nPre: If shortDenseTS is TRUE, number of years prior to the disturbance used to calculate the pre-disturbance value
 - nDist: If shortDenseTS is TRUE, number of months used to quantify the time series value during the disturbance
 - nPostMin: If shortDenseTS is TRUE, min number of years after the disturbance used to quantify the recovery
 - nPostMax: If shortDenseTS is TRUE, max number of years after the disturbance used to quantify the recovery
 - tdist: the timing of the disturbance [observation number]

```{r}
# start clock
start_time <- Sys.time()
set_fast_options()

ifolder <- '../inst/extdata/'# 'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Data\\' # directory with NBR data
ofolder <- '../inst/extdata/' # 'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Test\\' # directory where the recovery indicators and temporary outputs will be saved

startyr <- as.Date('1999-01-01') # start date
endyr <- as.Date('2019-12-31') # end date
tempRes <- 'monthly' # daily, annual, monthly, or quart (yearly data not supported yet!)
tempFun <- 'max' # max or mean (function used for temporal aggregation of data)
timeThres <- 2 # in case of segmentations, the time period between the detected break and the disturbance should be less than timeThres years
slpThres <- 2 # the slope of the pre-disturbance period should be less than slpThres


if((tempRes == 'monthly') || (tempRes == 'daily')){
  # funSet <- list('input' = c('raw', 'smoothed', 'segmented', 'raw', 'smoothed', 'segmented'),# settings for the recovery indicators
  #                'shortDenseTS' = c( TRUE, TRUE, TRUE, TRUE, TRUE, TRUE),
  #                'nPre' = c(2,2,2,2,2,2),
  #                'nDist' = c(1,1,1,12,12,12),
  #                'nPostMin' = c(0,0,0,4,4,4),
  #                'nPostMax' = c(1,1,1,6,6,6),
  #                'h' = c(0.15,0.15,0.15,0.15,0.15,0.15))
    funSet <- list('input' = c( 'segmented'),# settings for the recovery indicators
                 'shortDenseTS' = c( TRUE),
                 'nPre' = c(2),
                 'nDist' = c(12),
                 'nPostMin' = c(4),
                 'nPostMax' = c(6),
                 'h' = c(0.15))
} else if (tempRes == 'annual'){
  funSet <- list('input' = c('raw'),# settings for the recovery indicators
                 'shortDenseTS' = c( FALSE),
                 'nPre' = c(2),
                 'nDist' = c(12),
                 'nPostMin' = c(4),
                 'nPostMax' = c(6),
                 'h' = c(0.15))
}

```

# Import data 
```{r}
# one landsat tile (to extract the raster properties)
rst <- raster(file.path(ifolder, 'LC08_L1TP_225064_20170821_20170911_01_T1_sr_band7_crop.tif'))

# MapBiomas land cover 
lc <- stack(file.path(ifolder, 'COLECAO_4_1_CONSOLIDACAO_amazonia_crop.tif'))
dtslc <- as.Date(paste0(1985:2018, '-01-01'), format = '%Y-%m-%d')# dates of each layer
names(lc) <- dtslc
lc <- lc[[which((dtslc >= startyr) & (dtslc <= endyr))]]# remove observations outside the predefined observation period

# Hansen land cover 
han_msk <- raster(file.path(ifolder, 'Hansen_GFC-2018-v1.6_datamask_crop.tif'))
han_cov <- raster(file.path(ifolder, 'Hansen_GFC-2018-v1.6_treecover2000_crop.tif'))
han_cov[han_msk == 0] <- NA # remove invalid observations
rm(han_msk)

# Fire data
fcl <- stack(file.path(ifolder,list.files(ifolder, pattern ='*CL_crop.tif')))# stack the raster layers of band 5
fjd <- stack(file.path(ifolder,list.files(ifolder, pattern ='*JD_crop.tif')))# stack the raster layers of band 5
fdts<- as.Date(names(fcl), format = "X%Y%m%d.ESACCI.L3S_FIRE.BA.MODIS.AREA_2.fv5.1.CL_crop") # dates associated with the fire data stack
names(fcl) <- fdts
names(fjd) <- fdts
fcl <- fcl[[which((fdts >= startyr) & (fdts <= endyr))]]# remove observations outside the predefined observation period
fjd <- fcl[[which((fdts >= startyr) & (fdts <= endyr))]]
fdts <- fdts[which((fdts >= startyr) & (fdts <= endyr))]

# 
```

# Resampling data to ca 30m spatial resolution
General preprocessing of the data: change the spatial resolution, CRS and extent
```{r}
# crop and change spatial resolution of fire stack
fcl30 <- projectRaster(fcl, crs = crs(rst))
fcl30 <- resample(fcl30, rst, method="ngb")#resample to 30 m spatial resolution

fjd30 <- projectRaster(fjd, crs = crs(rst))
fjd30 <- resample(fjd30, rst, method="ngb")

lc30 <- projectRaster(lc, crs = crs(rst))
lc30 <- resample(lc30, rst, method="ngb")

han30 <- projectRaster(han_cov, crs = crs(rst))
han30 <- resample(han30, rst, method="ngb")

```

# Select pixels of interest
Only process data of pixels that are relevant:

- no agricultural land use since 2000 (MapBiomas)
- classified as forest in 2000 (MapBiomas)
- high tree cover in 2000 (Hansen dataset)
- high confidence of fire after 2000 (CCI Fire dataset; is added in the next code section)

```{r}
# select areas that consist of only natural land cover types
msklc <- lc30
msklc <- ((msklc==9) | ((msklc >= 14) & (msklc<= 22)) | (msklc >= 24))
msklc <- sum(msklc)
msklc <- (msklc == 0)

# select areas that were forested in 2000
mskfor <- (lc30$X2000.01.01 < 6)

# select areas with tree cover larger than 80% in 2000
mskcov <- (han30 > 80)

# total mask
msk <- ((msklc ==1) & (mskfor == 1) & (mskcov == 1))*1
msk[is.na(msk)] <- 0

rm(msklc, mskfor, mskcov)

```

# Prepare fire data
The CCI Fire dataset consists of a raster stack with monthly images containing a confidence layer (indicating the confidence that a fire occured) and a layer with the julian day of year for which the fire occured. Here, these layers are converted to one dataset:

- assign a value 0 if no fire occurs and a value 1 if a fire occurs
- change the temporal resolution of the dataset (given by tempRes)
- adjust the time span of the dataset (so it is fixed to the time window given by startyr and endyr)

```{r}
# generate an image stack containing regular fire time series at the predefined temporal resolution with value 1 if a fire occured and 0 if no fire occured
tsFire <- calc(stack(msk,fcl30, fjd30), function(x){createFireStack(x, dts = fdts, resol = tempRes, thres = 95)})#filename = paste0(ofolder, tsfile, '_Fire_', tempRes), overwrite=TRUE
rm(fcl, fjd, fcl30, fjd30)

# Get associated dates
dtsfr <- as.Date(toRegularTS(fdts, fdts, fun='max', resol = tempRes))
if(tempRes == 'monthly'){
  dtsfr <- rollback(dtsfr, roll_to_first = TRUE, preserve_hms = TRUE)
}
names(tsFire) <- dtsfr

# extend the fire data time span
rstNA <- rst
rstNA[] <- NA
dtstot <- as.Date(toRegularTS(c(startyr, dtsfr, endyr), c(startyr, dtsfr, endyr), fun='max', resol = tempRes))

for(i in 1:sum(dtstot<min(dtsfr))){tsFire <- addLayer(rstNA, tsFire)}
for(i in 1:sum(dtstot>max(dtsfr))){tsFire <- addLayer(tsFire,rstNA)}
names(tsFire) <- dtstot

# # update mask with locations that experienced fire 
msk <- (sum(tsFire, na.rm=T) > 0) # areas that have experienced a fire get the value 1, other areas the value 0

```


# Prepare Landsat stacks
The Landsat raster stacks are prepared:

- load the cropped Landsat tiles per sensor
- calculate a vegetation index
- remove the observations flagged as having a low quality
- adjust the temporal resolution of the dataset (given by tempRes)
- adjust the time span of the dataset (so it is fixed between the ime span given by startyr and endyr)

```{r}
# landsat 8
B7 <- stack(file.path(ifolder,list.files(ifolder, pattern ='LC08.*7_crop.tif')))# stack the raster layers of band 5
B5 <- stack(file.path(ifolder,list.files(ifolder, pattern ='LC08.*5_crop.tif'))) 
pix <- stack(file.path(ifolder,list.files(ifolder, pattern ='LC08.*_pixel_qa_crop.tif')))
radsat <- stack(file.path(ifolder,list.files(ifolder, pattern ='LC08.*_radsat_qa_crop.tif')))
dts8 <- as.Date(unlist(lapply(stringr::str_split(list.files(ifolder, pattern ='LC08.*7_crop.tif'), pattern = '_'),function(x) x[[4]])), format = "%Y%m%d")
NBR <- calcNBR(B5,B7) # calculate NBR
rm(B7, B5) # these bands are not needed anymore
br8 <- calc(stack(msk, NBR, pix, radsat), function(x){maskL8Stack(x)})# mask low quality observations, filename = paste0(ofolder, 'NBR_L7_masked'), overwrite=TRUE
rm(pix, radsat)# these data are not needed anymore

# landsat 7
B7 <- stack(file.path(ifolder,list.files(ifolder, pattern ='LE07.*7_crop.tif')))# stack the raster layers of band 5
B4 <- stack(file.path(ifolder,list.files(ifolder, pattern ='LE07.*4_crop.tif'))) 
pix <- stack(file.path(ifolder,list.files(ifolder, pattern ='LE07.*_pixel_qa_crop.tif')))
radsat <- stack(file.path(ifolder,list.files(ifolder, pattern ='LE07.*_radsat_qa_crop.tif')))
cloud <- stack(file.path(ifolder,list.files(ifolder, pattern ='LE07.*_sr_cloud_qa_crop.tif')))
dts7 <- as.Date(unlist(lapply(stringr::str_split(list.files(ifolder, pattern ='LE07.*7_crop.tif'), pattern = '_'),function(x) x[[4]])), format = "%Y%m%d")# get the dates of each layer

NBR <- calcNBR(B4,B7) # calculate NBR
rm(B7, B4) # these bands are not needed anymore

br7 <- calc(stack(msk, NBR, cloud, pix, radsat), function(x){maskL47Stack(x)})# mask low quality observations, filename = paste0(ofolder, 'NBR_L7_masked'), overwrite=TRUE
rm(cloud, pix, radsat)# these data are not needed anymore

# landsat 5
B7 <- stack(file.path(ifolder,list.files(ifolder, pattern ='LT05.*7_crop.tif')))# stack the raster layers of band 5
B4 <- stack(file.path(ifolder,list.files(ifolder, pattern ='LT05.*4_crop.tif'))) 
pix <- stack(file.path(ifolder,list.files(ifolder, pattern ='LT05.*_pixel_qa_crop.tif')))
radsat <- stack(file.path(ifolder,list.files(ifolder, pattern ='LT05.*_radsat_qa_crop.tif')))
cloud <- stack(file.path(ifolder,list.files(ifolder, pattern ='LT05.*_sr_cloud_qa_crop.tif')))
dts5 <- as.Date(unlist(lapply(stringr::str_split(list.files(ifolder, pattern ='LT05.*7_crop.tif'), pattern = '_'),function(x) x[[4]])), format = "%Y%m%d")# get the dates of each layer

NBR <- calcNBR(B4,B7) # calculate NBR
rm(B7, B4) # these bands are not needed anymore

br5 <- calc(stack(msk, NBR, cloud, pix, radsat), function(x){maskL47Stack(x)}, filename = paste0(ofolder, 'NBR_L5_masked'), overwrite=TRUE)# mask low quality observations
rm(cloud, pix, radsat)# these data are not needed anymore

# combine landsat 5, 7 and 8 stacks
dts <- c(dts5, dts7)
br <- stack(br5, br7)

br <- br[[which((dts >= startyr) & (dts <= endyr))]]
dts <- dts[which((dts >= startyr) & (dts <= endyr))]

# resample landsat data to temporal resolution of interest
# Create regular time series 
tsbr <- calc(stack(msk,br), function(x){toRegularTSStack(x, dts, fun = tempFun, resol = tempRes)},  overwrite=TRUE)#filename = paste0(ofolder, tsfile, '_', tempRes, '_', tempFun),
rm(br)
  dtsbr <- as.Date(toRegularTS(dts, dts, fun='max', resol = tempRes))
if(tempRes == 'monthly'){
  dtsbr <- rollback(dtsbr, roll_to_first = TRUE, preserve_hms = TRUE)
} 
# add observations to fix the time span between the start and end date
for(i in 1:sum(dtstot<min(dtsbr))){tsbr <- addLayer(rstNA, tsbr)}
for(i in 1:sum(dtstot>max(dtsbr))){tsbr <- addLayer(tsbr,rstNA)}
names(tsbr) <- dtstot

```

# Calculate recovery indicators
Three recovery indicators are computed: the RRI, R80P, and YrYr
```{r}
# # combine mask, fire and nbr stacks into one stack
st <- stack(msk, tsFire, tsbr)
rm(tsbr, tsFire)

# calculate stability indicators
# RRI,R80P, YrYr

start_time_rec <- Sys.time()
for(i in 1:length(funSet[[1]])){# iterate over the settings to derive the recovery indicators
  # get the correct number of observations per year
   if(tempRes == 'monthly') {
    obspyr = 12} else if(tempRes == 'daily'){obspyr = 365}else if(tempRes == 'annual'){obspyr = 1}
  
  # calculate the recovery indicators
  out <- calc(st, function(x){calcRecoveryStack(x, maxBreak=F, obspyr=obspyr, inp = funSet$input[i], shortDenseTS = funSet$shortDenseTS[i], nPre = funSet$nPre[i], nDist = funSet$nDist[i], nPostMin = funSet$nPostMin[i],
                                                nPostMax = funSet$nPostMax[i], h = funSet$h[i], timeThres, slpThres)}, 
              filename = paste0(ofolder, 'Stab_', tempRes, '_maxBreak_F', '_obspyr_', obspyr, '_inp_', funSet$input[i], '_shortDenseTS_', funSet$shortDenseTS[i], '_nPre_',  funSet$nPre[i], '_nDist_', funSet$nDist[i], '_nPostMin_', funSet$nPostMin[i], '_nPostMax_' , funSet$nPostMax[i], '_h_', funSet$h[i]*100, '_', timeThres, '_', slpThres), overwrite=TRUE)
}
end_time_rec <- Sys.time()

```










