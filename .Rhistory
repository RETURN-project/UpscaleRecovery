startyr
endyr
out <- br
npre <- sum(dtstot<min(dtsbr))# missing dates at the start of the study period
npost <- sum(dtstot>max(dtsbr))# missing dates at the end of the study period
npre
npost
if(npre>0){for(i in 1:npre){out <- addLayer(rstNA, out)}}else{# add observations at the beginning if needed
# remove observations before the start of the study period if needed
ind <- which(dtsbr>=min(dtstot))
out <- out[[ind]]
}
if(npost>0){for(i in 1:npost){out <- addLayer(out,rstNA)}}else{# add observations at the end if needed
# remove observations after the end of the study period if needed
ind <- which(dtsbr<=max(dtstot))
out <- out[[ind]]
}
out
br
dtstot
dtsbr
dtstot>max(dtsbr)
dtstot <- as.Date(dtstot)
dtstot
npre <- sum(dtstot<min(dtsbr))# missing dates at the start of the study period
npost <- sum(dtstot>max(dtsbr))# missing dates at the end of the study period
npost
install()
library(UpscaleRecovery)
setPeriod(st, starttime, endtime,tempRes, dts)
st1 <- setPeriod(st, starttime, endtime,tempRes, dts)
st1[1]
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
st1 <- setPeriod(st, starttime, endtime,tempRes, dts)
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
st2
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
st2
dts
br <-st
dtsbr <- st
rstNA <- br[[1]]
rstNA[] <- NA # empty image
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3])) # create date object from start date
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))# create date object from end date
dtstot <- date_decimal(as.numeric(time(toRegularTS(c(startyr, dtsbr, endyr), c(startyr, dtsbr, endyr), fun='max', resol = tempRes))))# all dates that should be covered in study period
dtstot <- as.Date(dtstot)
ut <- br
npre <- sum(dtstot<min(dtsbr))# missing dates at the start of the study period
npost <- sum(dtstot>max(dtsbr))# missing dates at the end of the study period
out <- br
npre <- sum(dtstot<min(dtsbr))# missing dates at the start of the study period
npost <- sum(dtstot>max(dtsbr))# missing dates at the end of the study period
npre
sum(dtstot<min(dtsbr))
dtstot
startyr
endyr
dtstot <- date_decimal(as.numeric(time(toRegularTS(c(startyr, dtsbr, endyr), c(startyr, dtsbr, endyr), fun='max', resol = tempRes))))# all dates that should be covered in study period
starttime <- c(2000,2,1)
endtime <- c(2000,4,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
st2
starttime <- c(2000,2,1)
endtime <- c(2000,5,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
st2
tres <- c('1 month', '3 months', '1 day', '1 year')
names(tres) <- c('monthly', 'quarterly', 'daily', 'yearly')
seq(startyr, endyr, by = tres[tempRes])
startyr
startyr
endyr
seq(startyr, endyr, by = '1 day')
seq(startyr, endyr, by = '3 months')
seq(startyr, endyr, by = '1 year')
install()
install()
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
st2
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
tres <- c('1 month', '3 months', '1 day', '1 year')
names(tres) <- c('monthly', 'quarterly', 'daily', 'yearly')
# make sure that image stack covers time period of interest
rstNA <- br[[1]]
rstNA[] <- NA # empty image
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3])) # create date object from start date
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))# create date object from end date
dtstot <- seq(startyr, endyr, by = tres[tempRes])
dtstot
out <- br
npre <- sum(dtstot<min(dtsbr))# missing dates at the start of the study period
npost <- sum(dtstot>max(dtsbr))# missing dates at the end of the study period
dtstot
dtsbr
dts <- seq(as.Date('2000-01-01'), as.Date('2000-04-01'), by = '1 month')
dtsbr <- dts
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
tres <- c('1 month', '3 months', '1 day', '1 year')
names(tres) <- c('monthly', 'quarterly', 'daily', 'yearly')
# make sure that image stack covers time period of interest
rstNA <- br[[1]]
rstNA[] <- NA # empty image
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3])) # create date object from start date
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))# create date object from end date
dtstot <- seq(startyr, endyr, by = tres[tempRes])
out <- br
npre <- sum(dtstot<min(dtsbr))# missing dates at the start of the study period
npost <- sum(dtstot>max(dtsbr))# missing dates at the end of the study period
npre
npost
if(npre>0){for(i in 1:npre){out <- addLayer(rstNA, out)}}else{# add observations at the beginning if needed
# remove observations before the start of the study period if needed
ind <- which(dtsbr>=min(dtstot))
out <- out[[ind]]
}
out
if(npost>0){for(i in 1:npost){out <- addLayer(out,rstNA)}}else{# add observations at the end if needed
# remove observations after the end of the study period if needed
ind <- which(dtsbr<=max(dtstot))
out <- out[[ind]]
}
out
out <- br
npre <- sum(dtstot<min(dtsbr))# missing dates at the start of the study period
npost <- sum(dtstot>max(dtsbr))# missing dates at the end of the study period
if(npre>0){for(i in 1:npre){out <- addLayer(rstNA, out)}}else{# add observations at the beginning if needed
# remove observations before the start of the study period if needed
ind <- which(dtsbr>=min(dtstot))
dtsbr <- dtsbr[ind]
out <- out[[ind]]
}
dtsbr
out
if(npost>0){for(i in 1:npost){out <- addLayer(out,rstNA)}}else{# add observations at the end if needed
# remove observations after the end of the study period if needed
ind <- which(dtsbr<=max(dtstot))
out <- out[[ind]]
}
out
install()
install()
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
exp <- c(NA, NA, NA, NA, NA, 1, 13, 25, 37, NA, NA, NA, NA, NA, NA, NA, NA, NA)
expect_equal(as.numeric(st2[1]), exp)
st2
install()
library(UpscaleRecovery)
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
est_that("change time span of raster stack", {
r1 <- raster(vals = 1:12, nrows = 3, ncols = 4)
r2 <- raster(vals = 13:24, nrows = 3, ncols = 4)
r3 <- raster(vals = 25:36, nrows = 3, ncols = 4)
r4 <- raster(vals = 37:48, nrows = 3, ncols = 4)
st <- stack(r1,r2,r3,r4)
tempRes <- 'monthly'
dts <- seq(as.Date('2000-01-01'), as.Date('2000-04-01'), by = '1 month')
starttime <- c(1999,8,1)
endtime <- c(2001,1,1)
st1 <- setPeriod(st, starttime, endtime,tempRes, dts)
exp <- c(NA, NA, NA, NA, NA,  1, 13, 25, 37, NA, NA, NA, NA, NA, NA, NA, NA, NA)
expect_equal(as.numeric(st1[1]), exp)
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
st2
r1 <- raster(vals = 1:12, nrows = 3, ncols = 4)
r2 <- raster(vals = 13:24, nrows = 3, ncols = 4)
r3 <- raster(vals = 25:36, nrows = 3, ncols = 4)
r4 <- raster(vals = 37:48, nrows = 3, ncols = 4)
st <- stack(r1,r2,r3,r4)
tempRes <- 'monthly'
dts <- seq(as.Date('2000-01-01'), as.Date('2000-04-01'), by = '1 month')
#
starttime <- c(1999,8,1)
endtime <- c(2001,1,1)
st1 <- setPeriod(st, starttime, endtime,tempRes, dts)
exp <- c(NA, NA, NA, NA, NA,  1, 13, 25, 37, NA, NA, NA, NA, NA, NA, NA, NA, NA)
expect_equal(as.numeric(st1[1]), exp)
st1
starttime <- c(1999,8,1)
endtime <- c(2001,1,1)
starttime <- c(1999,8,1)
endtime <- c(2001,1,1)
st
setPeriod(st, starttime, endtime,tempRes, dts)
tres <- c('1 month', '3 months', '1 day', '1 year')
names(tres) <- c('monthly', 'quarterly', 'daily', 'yearly')
# make sure that image stack covers time period of interest
rstNA <- br[[1]]
rstNA[] <- NA # empty image
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3])) # create date object from start date
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))# create date object from end date
dtstot <- seq(startyr, endyr, by = tres[tempRes])
br
dtsbr
out <- br
npre <- sum(dtstot<min(dtsbr))# missing dates at the start of the study period
npost <- sum(dtstot>max(dtsbr))# missing dates at the end of the study period
if(npre>0){for(i in 1:npre){out <- addLayer(rstNA, out)}}
# else{# add observations at the beginning if needed
# remove observations before the start of the study period if needed
#   ind <- which(dtsbr>=min(dtstot))
#   dtsbr <- dtsbr[ind]
#   out <- out[[ind]]
# }
if(npost>0){for(i in 1:npost){out <- addLayer(out,rstNA)}}
# else{# add observations at the end if needed
#   # remove observations after the end of the study period if needed
#   ind <- which(dtsbr<=max(dtstot))
#   out <- out[[ind]]
# }
out <- out[[which((dtsbr>=min(dtstot)) | (dtsbr<=max(dtstot)))]]# remove observations that fall outside the study period
out
which((dtsbr>=min(dtstot)) | (dtsbr<=max(dtstot)))
install()
r1 <- raster(vals = 1:12, nrows = 3, ncols = 4)
r2 <- raster(vals = 13:24, nrows = 3, ncols = 4)
r3 <- raster(vals = 25:36, nrows = 3, ncols = 4)
r4 <- raster(vals = 37:48, nrows = 3, ncols = 4)
st <- stack(r1,r2,r3,r4)
tempRes <- 'monthly'
dts <- seq(as.Date('2000-01-01'), as.Date('2000-04-01'), by = '1 month')
# case 1 - append start and end
starttime <- c(1999,8,1)
endtime <- c(2001,1,1)
st1 <- setPeriod(st, starttime, endtime,tempRes, dts)
exp <- c(NA, NA, NA, NA, NA,  1, 13, 25, 37, NA, NA, NA, NA, NA, NA, NA, NA, NA)
expect_equal(as.numeric(st1[1]), exp)
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
tres <- c('1 month', '3 months', '1 day', '1 year')
names(tres) <- c('monthly', 'quarterly', 'daily', 'yearly')
# make sure that image stack covers time period of interest
rstNA <- br[[1]]
rstNA[] <- NA # empty image
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3])) # create date object from start date
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))# create date object from end date
dtstot <- seq(startyr, endyr, by = tres[tempRes])
dtstot
out <- br
out <- out[[which((dtsbr>=min(dtstot)) | (dtsbr<=max(dtstot)))]]# remove observations that fall outside the study period
npre <- sum(dtstot<min(dtsbr))# missing dates at the start of the study period
npost <- sum(dtstot>max(dtsbr))# missing dates at the end of the study period
out
max(dtstot)
min(dtstot)
which((dtsbr>=min(dtstot)) & (dtsbr<=max(dtstot)))
dtsbr
install()
starttime <- c(2000,2,1)
endtime <- c(2000,3,1)
st2 <- setPeriod(st, starttime, endtime,tempRes, dts)
st2
exp <- c(13, 25)
expect_equal(as.numeric(st2[1]), exp)
document()
library(testthat)
document()
library(devtools)
document()
install()
library(UpscaleRecovery)
test_that("Straight line time series", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2, 10, by = 0.1)
c <- 10
m <- 3.14
ys <- c + m * ts
expect_equal(yryr(ts, ys), m, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = -1, deltat = 3), m, tolerance = 1e-6)
})
test_that("Sinusoidal time series", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2*pi, 10*pi, by = 0.01*pi)
ys <- sin(ts)
# Sampling after whole periods should yield a 0 mean slope
expect_equal(yryr(ts, ys, tpert = 0, deltat = 1*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = 0, deltat = 2*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = pi, deltat = 2*pi), 0, tolerance = 1e-6)
})
test_that("NAs are tolerated", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2*pi, 10*pi, by = 0.01*pi)
ts[30] <- NA
ys <- sin(ts)
# Sampling after whole periods should yield a 0 mean slope
expect_equal(yryr(ts, ys, tpert = 0, deltat = 1*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = 0, deltat = 2*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = pi, deltat = 2*pi), 0, tolerance = 1e-6)
})
test_that("Non matching lengths", {
# Generate a bad time series (different vector sizes)
ts <- seq(-2, 10, by = 0.1)
ys <- seq(-2, 10, by = 0.2)
expect_error(yryr(ts, ys),
"'x' and 'y' lengths differ")
})
context("Recovery indicator: YrYr")
test_that("Straight line time series", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2, 10, by = 0.1)
c <- 10
m <- 3.14
ys <- c + m * ts
expect_equal(yryr(ts, ys), m, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = -1, deltat = 3), m, tolerance = 1e-6)
})
test_that("Sinusoidal time series", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2*pi, 10*pi, by = 0.01*pi)
ys <- sin(ts)
# Sampling after whole periods should yield a 0 mean slope
expect_equal(yryr(ts, ys, tpert = 0, deltat = 1*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = 0, deltat = 2*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = pi, deltat = 2*pi), 0, tolerance = 1e-6)
})
test_that("NAs are tolerated", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2*pi, 10*pi, by = 0.01*pi)
ts[30] <- NA
ys <- sin(ts)
# Sampling after whole periods should yield a 0 mean slope
expect_equal(yryr(ts, ys, tpert = 0, deltat = 1*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = 0, deltat = 2*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = pi, deltat = 2*pi), 0, tolerance = 1e-6)
})
test_that("Non matching lengths", {
# Generate a bad time series (different vector sizes)
ts <- seq(-2, 10, by = 0.1)
ys <- seq(-2, 10, by = 0.2)
expect_error(yryr(ts, ys),
"'x' and 'y' lengths differ")
})
test_that("Out of bounds", {
# Generate a bad time series (different vector sizes)
ts <- seq(-2, 10, by = 0.1)
ys <- seq(-2, 10, by = 0.1)
expect_error(yryr(ts, ys, tpert = 9, deltat = 2),
"*bounds*")
})
context("Recovery indicator: R80p")
test_that("Fully recovered time series", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1)
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.5)
expect_equal(r80p(ts, ys), 1 / 0.8, tolerance = 1e-2)
})
test_that("NAs are tolerated", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1)
ts[5] <- NA # Introduce NA
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.5)
expect_equal(r80p(ts, ys), 1 / 0.8, tolerance = 1e-2)
})
context("Recovery indicator: RRI")
test_that("Fully recovered time series", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1) # as a vector of times
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.25) # plus a vector of values
expect_equal(rri(ts, ys), 1, tolerance = 1e-4)
})
test_that("NAs are tolerated", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1)
ts[5] <- NA # Introduce NA
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.25) # plus a vector of values
expect_equal(rri(ts, ys), 2, tolerance = 1e-2)
})
test_that("Non matching lengths", {
# Generate a bad time series (different vector sizes)
ts <- seq(-2, 10, by = 0.1)
ys <- seq(-2, 10, by = 0.2)
expect_error(yryr(ts, ys),
"'x' and 'y' lengths differ")
})
test_that("NAs are tolerated", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2*pi, 10*pi, by = 0.01*pi)
ts[30] <- NA
ys <- sin(ts)
# Sampling after whole periods should yield a 0 mean slope
expect_equal(yryr(ts, ys, tpert = 0, deltat = 1*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = 0, deltat = 2*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = pi, deltat = 2*pi), 0, tolerance = 1e-6)
})
test_that("Non matching lengths", {
# Generate a bad time series (different vector sizes)
ts <- seq(-2, 10, by = 0.1)
ys <- seq(-2, 10, by = 0.2)
expect_error(yryr(ts, ys),
"'x' and 'y' lengths differ")
})
test_that("Out of bounds", {
# Generate a bad time series (different vector sizes)
ts <- seq(-2, 10, by = 0.1)
ys <- seq(-2, 10, by = 0.1)
expect_error(yryr(ts, ys, tpert = 9, deltat = 2),
"*bounds*")
})
test_that("Fully recovered time series", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1)
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.5)
expect_equal(r80p(ts, ys), 1 / 0.8, tolerance = 1e-2)
})
test_that("NAs are tolerated", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1)
ts[5] <- NA # Introduce NA
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.5)
expect_equal(r80p(ts, ys), 1 / 0.8, tolerance = 1e-2)
})
exponential <- function(t, offset = 0, pert = 0, tpert = 0, thalf = 1, noise = 0) {
r <- log(2)/thalf # Translate the half-life to a multiplicative constant
y <- offset + pert * exp(-r*(t-tpert)) * (t >= tpert)
y <- y + rnorm(length(t), sd = noise) # Add the noise
return(y)
}
test_that("Fully recovered time series", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1) # as a vector of times
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.25) # plus a vector of values
expect_equal(rri(ts, ys), 1, tolerance = 1e-4)
})
test_that("NAs are tolerated", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1)
ts[5] <- NA # Introduce NA
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.25) # plus a vector of values
expect_equal(rri(ts, ys), 1, tolerance = 1e-2)
})
test_that("NAs are tolerated", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1)
ts[5] <- NA # Introduce NA
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.5)
expect_equal(r80p(ts, ys), 1 / 0.8, tolerance = 1e-2)
})
test_that("Fully recovered time series", {
# Generate a time series
ts <- seq(-2, 10, by = 0.1)
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.5)
expect_equal(r80p(ts, ys), 1 / 0.8, tolerance = 1e-2)
})
test_that("Out of bounds", {
# Generate a bad time series (different vector sizes)
ts <- seq(-2, 10, by = 0.1)
ys <- seq(-2, 10, by = 0.1)
expect_error(yryr(ts, ys, tpert = 9, deltat = 2),
"*bounds*")
})
test_that("Non matching lengths", {
# Generate a bad time series (different vector sizes)
ts <- seq(-2, 10, by = 0.1)
ys <- seq(-2, 10, by = 0.2)
expect_error(yryr(ts, ys),
"'x' and 'y' lengths differ")
})
test_that("NAs are tolerated", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2*pi, 10*pi, by = 0.01*pi)
ts[30] <- NA
ys <- sin(ts)
# Sampling after whole periods should yield a 0 mean slope
expect_equal(yryr(ts, ys, tpert = 0, deltat = 1*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = 0, deltat = 2*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = pi, deltat = 2*pi), 0, tolerance = 1e-6)
})
test_that("Sinusoidal time series", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2*pi, 10*pi, by = 0.01*pi)
ys <- sin(ts)
# Sampling after whole periods should yield a 0 mean slope
expect_equal(yryr(ts, ys, tpert = 0, deltat = 1*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = 0, deltat = 2*pi), 0, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = pi, deltat = 2*pi), 0, tolerance = 1e-6)
})
test_that("Straight line time series", {
# Generate a time series (straight line of slope m and intercept c)
ts <- seq(-2, 10, by = 0.1)
c <- 10
m <- 3.14
ys <- c + m * ts
expect_equal(yryr(ts, ys), m, tolerance = 1e-6)
expect_equal(yryr(ts, ys, tpert = -1, deltat = 3), m, tolerance = 1e-6)
})
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.25) # plus a vector of values
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.25)
ts <- seq(-2, 10, by = 0.1) # as a vector of times
ys <- exponential(ts, pert = -2, offset = 1, thalf = 0.25) # plus a vector of values
ys
plot(ys)
document()
rm(exponential)
document()
rm(ts)
document()
install()
