paste0(as.character(as.numeric(intToBits(2))[1:2]), sep='')
paste0(as.numeric(intToBits(2)[1:2]), sep='')
paste0(as.numeric(intToBits(2)[1:2]))
as.numeric(intToBits(2)[1:2])
paste(as.numeric(intToBits(2)[1:2]), collapse = '')
paste(t(as.numeric(intToBits(2)[1:2])), collapse = '')
paste(rev(as.numeric(intToBits(2)[1:2])), collapse = '')
valid = 0, cloud = 0, shadow = 0, snow = 0, water = 0, aero = 0, subzero = 0, sat = 0, sunZen = 0, illum = 0, slope = 0, wvp = 0
getQA <- function(valid = 0, cloud = 0, shadow = 0, snow = 0, water = 0, aero = 0, subzero = 0, sat = 0, sunZen = 0, illum = 0, slope = 0, wvp = 0){
bcloud <- paste(rev(as.numeric(intToBits(cloud)[1:2])), collapse = '')
baero <- paste(rev(as.numeric(intToBits(aero)[1:2])), collapse = '')
billum <- paste(rev(as.numeric(intToBits(illum)[1:2])), collapse = '')
bitword <- paste0(0,wvp,slope,billum,sunZen,sat,subzero,baero,water,snow,shadow,bcloud, valid)
out <- BinToDec(bitword)
return(out)
}
getQA()
BinToDec <- function(x){
sum(2^(which(rev(unlist(strsplit(as.character(x), "")) == 1))-1))
}
getQA()
getQA(illum = 1, slope = 1, wvp = 1)
2^14 +2^13 + 2^12
valid = 0; cloud = 0; shadow = 0; snow = 0; water = 0; aero = 0; subzero = 0; sat = 0; sunZen = 0; illum = 1; slope = 1; wvp = 1
bcloud <- paste(rev(as.numeric(intToBits(cloud)[1:2])), collapse = '')
baero <- paste(rev(as.numeric(intToBits(aero)[1:2])), collapse = '')
billum <- paste(rev(as.numeric(intToBits(illum)[1:2])), collapse = '')
bitword <- paste0(0,wvp,slope,billum,sunZen,sat,subzero,baero,water,snow,shadow,bcloud, valid)
bitword
bcloud <- paste(as.numeric(intToBits(cloud)[1:2]), collapse = '')
baero <- paste(as.numeric(intToBits(aero)[1:2]), collapse = '')
billum <- paste(as.numeric(intToBits(illum)[1:2]), collapse = '')
bitword <- paste0(0,wvp,slope,billum,sunZen,sat,subzero,baero,water,snow,shadow,bcloud, valid)
bitword
out <- BinToDec(bitword)
out
getQA <- function(valid = 0, cloud = 0, shadow = 0, snow = 0, water = 0, aero = 0, subzero = 0, sat = 0, sunZen = 0, illum = 0, slope = 0, wvp = 0){
bcloud <- paste(as.numeric(intToBits(cloud)[1:2]), collapse = '')
baero <- paste(as.numeric(intToBits(aero)[1:2]), collapse = '')
billum <- paste(as.numeric(intToBits(illum)[1:2]), collapse = '')
bitword <- paste0(0,wvp,slope,billum,sunZen,sat,subzero,baero,water,snow,shadow,bcloud, valid)
out <- BinToDec(bitword)
return(out)
}
getQA(illum = 1, slope = 1, wvp = 1)
cmbs <- expand.grid(valid, cloud, shadow, snow, water, aero, subzero, sat, sunZen,illum, slope, wvp)
cmbs
cmbs
valid = 0; cloud = 0; shadow = 0; snow = 0; water = 0; aero = 0; subzero = 0; sat = 0; sunZen = 0; illum = 1; slope = 1; wvp = 1
cmbs <- expand.grid(valid, cloud, shadow, snow, water, aero, subzero, sat, sunZen,illum, slope, wvp)
cmbs
cmbs <- expand.grid(valid, cloud, shadow, snow, water, aero=c(0,1), subzero, sat, sunZen,illum, slope, wvp)
cmbs[1,]
cmbs[2,]
cmbs <- expand.grid(valid=c(0,1), cloud, shadow, snow, water, aero=c(0,1), subzero, sat, sunZen,illum, slope, wvp)
cmbs[2,]
cmbs
typeof(cmbs)
mcmbs <- as.matrix(cmbs)
mcmbs
apply(mcmbs,1,FUN = getQA)
out <- apply(mcmbs,1,FUN = getQA)
out
out[1]
getQA(mcmbs[1,])
qetQA(cmbs)
getQA(cmbs)
getQA(as.data.frame(cmbs))
mcmbs <- as.data.frame(cmbs)
mcmbs
name(mcmbs) = c('valid', 'cloud', 'shadow', 'snow', 'water', 'aero', 'subzero', 'sat', 'sunZen', 'illum', 'slope', 'wvp')
names(mcmbs) = c('valid', 'cloud', 'shadow', 'snow', 'water', 'aero', 'subzero', 'sat', 'sunZen', 'illum', 'slope', 'wvp')
mcmbs
mcmbs[1,]
out <- apply(mcmbs,1,FUN = getQA)
out
getQA(mcmbs)
cmbs[[1]]
out <- c(outer(cmbs[[1]], cmbs[[2]], cmbs[[3]], cmbs[[4]],cmbs[[5]], cmbs[[6]],cmbs[[7]], cmbs[[8]],cmbs[[9]], cmbs[[10]],cmbs[[11]], cmbs[[12]],Vectorize(getQA)))
cmbs[[3]]
Vectorize(getQA)
out <- c(do.call("outer", c(unname(cmbs),Vectorize(getQA))))
names(cmbs)
names(cmbs) = c('valid', 'cloud', 'shadow', 'snow', 'water', 'aero', 'subzero', 'sat', 'sunZen', 'illum', 'slope', 'wvp')
names(cmbs)
out <- sapply(cmbs, function(x){getQA(x$valid, x$cloud, x$shadow, x$snow, x$water, x$aero, x$subzero, x$sat, x$sunZen, x$illum, x$slope, x$wvp)})
mcmbs <- as.data.frame(cmbs)
names(mcmbs) = c('valid', 'cloud', 'shadow', 'snow', 'water', 'aero', 'subzero', 'sat', 'sunZen', 'illum', 'slope', 'wvp')
out <- sapply(mcmbs, function(x){getQA(x$valid, x$cloud, x$shadow, x$snow, x$water, x$aero, x$subzero, x$sat, x$sunZen, x$illum, x$slope, x$wvp)})
out <- mapply(getQA,mcmbs$valid, mcmbs$cloud, mcmbs$shadow, mcmbs$snow, mcmbs$water, mcmbs$aero, mcmbs$subzero, mcmbs$sat, mcmbs$sunZen, mcmbs$illum, mcmbs$slope, mcmbs$wvp))
out <- mapply(getQA,mcmbs$valid, mcmbs$cloud, mcmbs$shadow, mcmbs$snow, mcmbs$water, mcmbs$aero, mcmbs$subzero, mcmbs$sat, mcmbs$sunZen, mcmbs$illum, mcmbs$slope, mcmbs$wvp)
out
getQAvals <- function(valid = 0, cloud = 0, shadow = 0, snow = 0, water = 0, aero = 0, subzero = 0, sat = 0, sunZen = 0, illum = 0, slope = 0, wvp = 0){
cmbs <- expand.grid(valid, cloud, shadow, snow, water, aero, subzero, sat, sunZen,illum, slope, wvp)
names(cmbs) = c('valid', 'cloud', 'shadow', 'snow', 'water', 'aero', 'subzero', 'sat', 'sunZen', 'illum', 'slope', 'wvp')
# convert to dataframe
mcmbs <- as.data.frame(cmbs)
names(mcmbs) = c('valid', 'cloud', 'shadow', 'snow', 'water', 'aero', 'subzero', 'sat', 'sunZen', 'illum', 'slope', 'wvp')
# get qa values of all inputs
out <- mapply(getQA,mcmbs$valid, mcmbs$cloud, mcmbs$shadow, mcmbs$snow, mcmbs$water, mcmbs$aero, mcmbs$subzero, mcmbs$sat, mcmbs$sunZen, mcmbs$illum, mcmbs$slope, mcmbs$wvp)
return(out)
}
library(raster)
im <-  nbri
msk = raster(im, vals = 0)
?raster
msk <- im
msk
msk[] <- 0
msk
?sapply
mskQA <- function(im, qaim, valid = 0, cloud = 0, shadow = 0, snow = 0, water = 0, aero = 0, subzero = 0, sat = 0, sunZen = 0, illum = 0, slope = 0, wvp = 0){
toKeep <- getQAvals(valid, cloud, shadow, snow, water, aero, subzero, sat, sunZen, illum, slope, wvp)
msk <- qaim
msk[] <- 0
for(i in 1:length(toKeep)){
msk[qaim == toKeep[i]] <- 1
}
im[qaim == 0] <- NA
}
plot(qaim)
qaimf <- as.factor(qaim)
plot(qaimf)
qaimf
# qim <- raster(file.path(forcefolder,l2folder,gsub("BOA", "QIM", img[i])))
for(i in 1:length(img)){
# open image
im <- stack(file.path(forcefolder,l2folder,img[i]))
qaim <- raster(file.path(forcefolder,l2folder,gsub("BOA", "QAI", img[i])))
# calculate NBR
nbri <- switch(1+ ((lsens[i] == 'SEN2A') | (lsens[i] == 'SEN2B')), calcNBR(im[[4]], im[[6]]), calcNBR(im[[8]], im[[10]]))
# mask low quality data
nbrf <- maskQA(nbri, qaim)
# mask data using forest fire mask
# add to stack
if(i == 1){
st <- nbrf
}else{
st <- addLayer(st, nbrf)
}
rm(nbri, nbrf, im)
}
i=1
im <- stack(file.path(forcefolder,l2folder,img[i]))
qaim <- raster(file.path(forcefolder,l2folder,gsub("BOA", "QAI", img[i])))
# calculate NBR
nbri <- switch(1+ ((lsens[i] == 'SEN2A') | (lsens[i] == 'SEN2B')), calcNBR(im[[4]], im[[6]]), calcNBR(im[[8]], im[[10]]))
# mask low quality data
nbrf <- maskQA(nbri, qaim)
mskQA <- function(im, qaim, valid = 0, cloud = 0, shadow = 0, snow = 0, water = 0, aero = 0, subzero = 0, sat = 0, sunZen = 0, illum = 0, slope = 0, wvp = 0){
# QA values of pixels that shouldn't be masked
toKeep <- getQAvals(valid, cloud, shadow, snow, water, aero, subzero, sat, sunZen, illum, slope, wvp)
# make raster with 0 values for pixels that should be masked and 1 for pixels that should be kept
msk <- qaim
msk[] <- 0
for(i in 1:length(toKeep)){
msk[qaim == toKeep[i]] <- 1
}
# mask values
im[qaim == 0] <- NA
}
# mask low quality data
nbrf <- maskQA(nbri, qaim)
# mask low quality data
nbrf <- mskQA(nbri, qaim)
qim <- raster(file.path(forcefolder,l2folder,gsub("BOA", "QIM", img[i])))
qim <- stack(file.path(forcefolder,l2folder,gsub("BOA", "QIM", img[i])))
plot(qim[1])
plot(qim[[1]])
plot(qim[[2]])
qim
plot(qim[[3]])
plot(qim[[4]])
plot(qim[[5]])
plot(qim[[6]])
plot(qim[[7]])
plot(qim[[8]])
plot(qim[[9]])
plot(qim[[10]])
plot(qim[[11]])
plot(qim[[12]])
plot(qim[[9]])
plot(qim[[6]])
qim[[6]][1]
qim[[6]][100]
qim[[6]][100000]
levels(qaimf)
intToBits(levels(qaimf))
intToBits(as.numeric(levels(qaimf)))
(as.numeric(levels(qaimf)))
((levels(qaimf)))
tst <- ((levels(qaimf)))
(unlist(levels(qaimf)))
intToBits(unlist(levels(qaimf)))
intToBits(as.numeric(unlist(levels(qaimf))))
tst <- intToBits(as.numeric(unlist(levels(qaimf))))
tst <- (as.numeric(unlist(levels(qaimf))))
tst
plot(nbri)
plot(nbrf)
nbrf
mskQA <- function(im, qaim, valid = 0, cloud = 0, shadow = 0, snow = 0, water = 0, aero = 0, subzero = 0, sat = 0, sunZen = 0, illum = 0, slope = c(0,1), wvp = 0){
# QA values of pixels that shouldn't be masked
toKeep <- getQAvals(valid, cloud, shadow, snow, water, aero, subzero, sat, sunZen, illum, slope, wvp)
# make raster with 0 values for pixels that should be masked and 1 for pixels that should be kept
msk <- qaim
msk[] <- 0
for(i in 1:length(toKeep)){
msk[[qaim == toKeep[i]]] <- 1
}
# mask values
im[[qaim == 0]] <- NA
}
# mask low quality data
nbrf <- mskQA(nbri, qaim)
nbrf
toKeep <- getQAvals(valid, cloud, shadow, snow, water, aero, subzero, sat, sunZen, illum, slope, wvp)
toKeep
# make raster with 0 values for pixels that should be masked and 1 for pixels that should be kept
msk <- qaim
msk[] <- 0
for(i in 1:length(toKeep)){
msk[[qaim == toKeep[i]]] <- 1
}
for(i in 1:length(toKeep)){
msk[qaim == toKeep[i]] <- 1
}
plot(msk)
plot(msk)
plot(msk)
plot(msk)
msk
mskQA <- function(im, qaim, valid = 0, cloud = 0, shadow = 0, snow = 0, water = 0, aero = 0, subzero = 0, sat = 0, sunZen = 0, illum = 0, slope = c(0,1), wvp = 0){
# QA values of pixels that shouldn't be masked
toKeep <- getQAvals(valid, cloud, shadow, snow, water, aero, subzero, sat, sunZen, illum, slope, wvp)
# make raster with 0 values for pixels that should be masked and 1 for pixels that should be kept
msk <- qaim
msk[] <- 0
for(i in 1:length(toKeep)){
msk[qaim == toKeep[i]] <- 1
}
# mask values
im[msk == 0] <- NA
}
# mask low quality data
nbrf <- mskQA(nbri, qaim, slope = c(0,1), aero = c(0,1))
plot(nbrf)
nbrf
im <- qaim
mskQA <- function(im, qaim, valid = 0, cloud = 0, shadow = 0, snow = 0, water = 0, aero = 0, subzero = 0, sat = 0, sunZen = 0, illum = 0, slope = 0, wvp = 0){
# QA values of pixels that shouldn't be masked
toKeep <- getQAvals(valid, cloud, shadow, snow, water, aero, subzero, sat, sunZen, illum, slope, wvp)
# make raster with 0 values for pixels that should be masked and 1 for pixels that should be kept
msk <- qaim
msk[] <- 0
for(i in 1:length(toKeep)){
msk[qaim == toKeep[i]] <- 1
}
# mask values
im[msk == 0] <- NA
return(im)
}
# mask low quality data
nbrf <- mskQA(nbri, qaim, slope = c(0,1), aero = c(0,1))
plot(nbrf)
img
for(i in 1:length(img)){
# open image
im <- stack(file.path(forcefolder,l2folder,img[i]))
qaim <- raster(file.path(forcefolder,l2folder,gsub("BOA", "QAI", img[i])))
# calculate NBR
nbri <- switch(1+ ((lsens[i] == 'SEN2A') | (lsens[i] == 'SEN2B')), calcNBR(im[[4]], im[[6]]), calcNBR(im[[8]], im[[10]]))
# mask low quality data
nbrf <- mskQA(nbri, qaim, slope = c(0,1), aero = c(0,1))
# mask data using forest fire mask
# add to stack
if(i == 1){
st <- nbrf
}else{
st <- addLayer(st, nbrf)
}
rm(nbri, nbrf, im)
}
plot(st[[]])
plot(st[[]])
plot(st[[1]])
plot(st[[2]])
plot(st[[3]])
plot(st[[4]])
# assign dates to stack
names(st) <- ldts
st
frq <- 'monthly'
fmask <- raster(file.path(forcefolder,l2folder,'mask.tif'))
plot(fmask)
fmask
st
tempFun <- 'mean'
tempRes <- 'monthly'
dtsbr <- as.Date(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
# generate a regular image stack
tsbr <- calc(stack(fmask,st), function(x){toRegularTSStack(x, ldts, fun = tempFun, resol = tempRes)})#, filename = paste0(ofolder, tsfile, '_', tempRes, '_', tempFun), overwrite=TRUE
mask <- apply(st, 1, FUN = function(x) { sum(is.na(x)) / length(x) } )
st
mask <- apply(c(NA,NA), 1, FUN = function(x) { sum(is.na(x)) / length(x) } )
mask <- apply(as.matrix(c(NA,NA,NA,NA),nrows = 2,ncols=2), 1, FUN = function(x) { sum(is.na(x)) / length(x) } )
mask
msk =c(0,0,0,0)
i <- ((mask < 1) & (msk == 1))
i
sum(i)
toRegularTSStack <- function(x, dts, fun, resol)
{
msk <- x[,1]
x <- x[,-1]
mask <- apply(x, 1, FUN = function(x) { sum(is.na(x)) / length(x) } )
i <- ((mask < 1) & (msk == 1))
len <- length(toRegularTS(dts, dts, fun=fun, resol = resol))
res <- matrix(NA, length(i), len)
if(sum(i) == 1) {
res[i,] <- toRegularTS(x[i,], dts, fun=fun, resol = resol)
} else if(sum(i) > 1) {
res[i,] <- t(apply(x[i,], 1, toRegularTS, dts, fun, resol))
}
res
}
# generate a regular image stack
tsbr <- calc(stack(fmask,st), function(x){toRegularTSStack(x, ldts, fun = tempFun, resol = tempRes)})#, filename = paste0(ofolder, tsfile, '_', tempRes, '_', tempFun), overwrite=TRUE
tsbr
# generate a regular image stack
tsbr <- calc(stack(fmask,st), function(x){toRegularTSStack(x, ldts, fun = tempFun, resol = tempRes)})#, filename = paste0(ofolder, tsfile, '_', tempRes, '_', tempFun), overwrite=TRUE
install()
library(devtools)
install()
library(UpscaleRecovery)
# generate a regular image stack
tsbr <- calc(stack(fmask,st), function(x){toRegularTSStack(x, ldts, fun = tempFun, resol = tempRes)})#, filename = paste0(ofolder, tsfile, '_', tempRes, '_', tempFun), overwrite=TRUE
stack(fmask,st)
plot(fmask)
tst <- stack(fmask,st)
tsti <- tst[1:5]
tsti
x <- tst[1:5]
msk <- x[,1]
msk
(mask < 1)
(msk == 1)
toRegularTSStack <- function(x, dts, fun, resol)
{
msk <- x[,1]
msk[is.na(msk)] <- 0
x <- x[,-1]
mask <- apply(x, 1, FUN = function(x) { sum(is.na(x)) / length(x) } )
i <- ((mask < 1) & (msk == 1))
len <- length(toRegularTS(dts, dts, fun=fun, resol = resol))
res <- matrix(NA, length(i), len)
if(sum(i) == 1) {
res[i,] <- toRegularTS(x[i,], dts, fun=fun, resol = resol)
} else if(sum(i) > 1) {
res[i,] <- t(apply(x[i,], 1, toRegularTS, dts, fun, resol))
}
res
}
# generate a regular image stack
tsbr <- calc(stack(fmask,st), function(x){toRegularTSStack(x, ldts, fun = tempFun, resol = tempRes)})#, filename = paste0(ofolder, tsfile, '_', tempRes, '_', tempFun), overwrite=TRUE
tsbr
dtsbr <- as.Date(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
toRegularTS(ldts, ldts, fun='max', resol = tempRes)
library(zoo)
dtsbr <- as.Date(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
library(ts)
install.packages('ts')
?ts
library(lubridate)
dtsbr <- as.Date(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
toRegularTS(ldts, ldts, fun='max', resol = tempRes)
library(zoo)
as.Date(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
time(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
time(toRegularTS(ldts, ldts, fun='max', resol = tempRes))[1]
library(timeseries)
as.Date(toRegularTS(ldts, ldts, fun='max', resol = tempRes), "%Y %j")
paste(start(toRegularTS(ldts, ldts, fun='max', resol = tempRes)), seq_along(toRegularTS(ldts, ldts, fun='max', resol = tempRes)))
start(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
seq_along(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
toRegularTS(ldts, ldts, fun='max', resol = tempRes)[]
as.Date(toRegularTS(ldts, ldts, fun='max', resol = tempRes)[])
zoo::as.Date(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
index(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
zoo::as.Date(index(toRegularTS(ldts, ldts, fun='max', resol = tempRes)))
as.Date(index(toRegularTS(ldts, ldts, fun='max', resol = tempRes)))
as.Date(as.numeric(time(toRegularTS(ldts, ldts, fun='max', resol = tempRes))))
ldts
toRegularTS(ldts, ldts, fun='max', resol = tempRes))
toRegularTS(ldts, ldts, fun='max', resol = tempRes)
time(toRegularTS(ldts, ldts, fun='max', resol = tempRes))
as.numeric(time(toRegularTS(ldts, ldts, fun='max', resol = tempRes)))
as.Date(as.numeric(time(toRegularTS(ldts, ldts, fun='max', resol = tempRes))))
zoo:as.Date(as.numeric(time(toRegularTS(ldts, ldts, fun='max', resol = tempRes))))
zoo::as.Date(as.numeric(time(toRegularTS(ldts, ldts, fun='max', resol = tempRes))))
library(lubridate)
lubridate::as.Date(as.numeric(time(toRegularTS(ldts, ldts, fun='max', resol = tempRes))))
tsi <- toRegularTS(ldts, ldts, fun='max', resol = tempRes)
as.Date(date_decimal(as.numeric(tsi)))
date_decimal(as.numeric(tsi))
as.numeric(tsi)
as.Date(as.numeric(time(tsi)))
time(tsi)
as.Date(time(tsi))
as.numeric(tsi)
as.Date(as.numeric(tsi))
dtsbr <- as.Date(as.numeric(toRegularTS(ldts, ldts, fun='max', resol = tempRes)))
dtsbr
tsi
time(tsi)
as.numeric(time(tsi))
as.Date(as.numeric(time(tsi)))
as.yearmon(time(tsi))
tsi
time(tsi)
tempRes
tsi
plot(tsi)
z <- zoo(ldts, ldts) ## create a zoo (time) series
mz <- as.ts(aggregate(z, as.yearmon, mmax))
z
aggregate(z, as.yearmon, mmax)
as.ts(aggregate(z, as.yearmon, mmax))
time(tsi)
date_decimal(tsi)
date_decimal(time(tsi))
date_decimala(time(tsi))
date_decimal(as.numeric(time(tsi)))
tsi
date_decimal(as.numeric(tsi))
ldts
aggregate(z, as.yearmon, mmax)
ldtsi <- c(ldts, as.Date('2001-04-05'))
z <- zoo(ldtsi, ldtsi) ## create a zoo (time) series
mz <- as.ts(aggregate(z, as.yearmon, mmax))
mz
as.Date(toRegularTS(ldtsi, ldtsi, fun='max', resol = tempRes))
# load fire data
fimg <- list.files(file.path(forcefolder,l2folder),'fire_X')
fst <- stack(fimg)
fst <- stack(file.path(forcefolder,l2folder),fimg))
fst <- stack(file.path(forcefolder,l2folder),fimg)
fst <- stack(file.path(forcefolder,l2folder,fimg))
fst
plot(fst[[1]])
plot(fst[[100]])
tsf <- stack(file.path(forcefolder,l2folder,fimg))
fimg
# assign dates to stack
dtsf <- as.Date(fimg,'fire_X%y_%m_%d.tif')
# assign dates to stack
dtsf <- as.Date(fimg,'fire_X%Y_%m_%d.tif')
tsf <- stack(file.path(forcefolder,l2folder,fimg))
dtsf <- as.Date
names(tsf) <- dtsf
tsf
# assign dates to stack
dtsf <- as.Date(fimg,'fire_X%Y_%m_%d.tif')
names(tsf) <- dtsf
tsf
dtsfr <- as.Date(fimg,'fire_X%Y_%m_%d.tif')
names(tsf) <- dtsfr
dtsfr
startdt <- max(c(min(dtsbr), min(dtsfr)))
enddt  <- min(c(max(dtsbr), max(dtsfr)))
startdt
enddt
min(dtsfr)
max(dtsfr)
starttime <- c(1998,1,01)#start date: year, month, day
endtime <- c(2018,12,01)#end date: year, month, day
as.Date(toRegularTS(c(startyr, dtsfr, endyr), c(startyr, dtsfr, endyr), fun='max', resol = tempRes))
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3]))
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))
dtstot <- as.Date(toRegularTS(c(startyr, dtsfr, endyr), c(startyr, dtsfr, endyr), fun='max', resol = tempRes))
starttime <- c(1998,1,01)#start date: year, month, day
endtime <- c(2018,12,01)#end date: year, month, day
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3]))
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))
dtstot <- as.Date(toRegularTS(c(startyr, dtsfr, endyr), c(startyr, dtsfr, endyr), fun='max', resol = tempRes))
as.Date(toRegularTS(c(startyr, dtsfr, endyr), c(startyr, dtsfr, endyr), fun='max', resol = tempRes))
dtstot
rstNA <- st[[1]]
rstNA[] <- NA
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3]))
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))
dtstot <- as.Date(toRegularTS(c(startyr, dtsfr, endyr), c(startyr, dtsfr, endyr), fun='max', resol = tempRes))
rstNA <- tsbr[[1]]
rstNA[] <- NA
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3]))
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))
dtstot <- as.Date(toRegularTS(c(startyr, dtsfr, endyr), c(startyr, dtsfr, endyr), fun='max', resol = tempRes))
rstNA <- tsbr[[1]]
rstNA[] <- NA
startyr <- as.Date(paste0(starttime[1],'-',starttime[2],'-',starttime[3]))
endyr <- as.Date(paste0(endtime[1],'-',endtime[2],'-',endtime[3]))
dtstot <- as.Date(toRegularTS(c(startyr, dtsfr, endyr), c(startyr, dtsfr, endyr), fun='max', resol = tempRes))
tsNBR <- tsbr
npre <- sum(dtstot<min(dtsfr))
npost <- sum(dtstot>max(dtsfr))
npre
npost
dtstot
npre <- sum(dtstot<min(dtsbr))
npost <- sum(dtstot>max(dtsbr))
npre
npost
