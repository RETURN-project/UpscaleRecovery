frq <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_Fire_quart.gri')))
frq <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_Fire_quart.gri')))
frq
dtsq <- loadRData(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_dts_quart_max')))
dtsq
stq
plot(stq[1])
plot(stq[[1]])
plot(stq[[81]])
ifolder <- 'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Data\\' # directory with NBR data
ofolder <- 'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Data\\' # directory where the recovery indicators and temporary outputs will be saved
firefolder <- 'C:\\Users\\keers001\\OneDrive - WageningenUR\\RETURN\\Data\\RETURN\\CCI_fire\\' #'\\\\WURNET.NL\\Homes\\keers001\\AppData\\FolderRedirection\\Desktop\\cci_fire2\\'
# directory where the fire data are stored
tsfile <- 'LSTS_SantaRem_area2_2000_2020'# name of the file with NBR time series
metafile <- 'LSTS_meta_SantaRem_area2_2000_2020'# metadata file of the NBR time series
firefile <- 'LSTS_FireArea_SantaRem_area2_2000_2020'# name of the file with the fire mask
tempRes <- 'quart' # daily, annual, monthly, or quart (yearly data not supported yet!)
tempFun <- 'max' # max or mean (function used for temporal aggregation of data)
timeThres <- 2 # in case of segmentations, the time period between the detected break and the disturbance should be less than timeThres years
slpThres <- 2 # the slope of the pre-disturbance period should be less than slpThres
# settings of the derived recovery indicators
# input: refers to the tine series pre-processing: raw (=no preprocessing), smoothed or segmented
# h: This parameter defines the minimal segment size either given as fraction relative to the sample size or as an integer giving the minimal number of observations in each segment.
# shortDenseTS: TRUE or FALSE. In case TRUE, the metrics are adjusted to be compatible with short, dense time series. In case FALSE, the input time series is assumed to have annual observations and at least 2 and 5 pre- and post-disturbance years, respectively.
# nPre: If shortDenseTS is TRUE, number of years prior to the disturbance used to calculate the pre-disturbance value
# nDist: If shortDenseTS is TRUE, number of months used to quantify the time series value during the disturbance
# nPostMin: If shortDenseTS is TRUE, min number of years after the disturbance used to quantify the recovery
# nPostMax: If shortDenseTS is TRUE, max number of years after the disturbance used to quantify the recovery
# tdist: the timing of the disturbance [observation number]
if((tempRes == 'monthly') || (tempRes == 'daily')){
funSet <- list('input' = c('raw', 'smoothed', 'segmented', 'raw', 'smoothed', 'segmented'),# settings for the recovery indicators
'shortDenseTS' = c( TRUE, TRUE, TRUE, TRUE, TRUE, TRUE),
'nPre' = c(2,2,2,2,2,2),
'nDist' = c(1,1,1,12,12,12),
'nPostMin' = c(0,0,0,4,4,4),
'nPostMax' = c(1,1,1,6,6,6),
'h' = c(0.15,0.15,0.15,0.15,0.15,0.15))
} else if (tempRes == 'annual'){
funSet <- list('input' = c('raw'),# settings for the recovery indicators
'shortDenseTS' = c( FALSE),
'nPre' = c(2),
'nDist' = c(12),
'nPostMin' = c(4),
'nPostMax' = c(6),
'h' = c(0.15))
}
br <- stack(paste0(ifolder,tsfile,'.tif'))# the data stack containing the vegetation response
br <- br[[-1]] # the first image is redundant, artefact from the GEE download script
meta <- read.csv(paste0(ifolder,metafile,'.csv'))# metadata associated with the image stack
dts <- as.Date(meta$system_time_start[-1],'%Y,%m,%d')# observation dates of the image stack
fre <- raster(paste0(ifolder,firefile,'.tif'))# raster of areas that experienced a fire (those have a value > 0)
fcl <- loadRData( file = file.path(firefolder, 'ESACCI-L3S_FIRE-BA-MODIS-AREA_2-fv5.1-CL-01-18.rda'))# fire confidence
fjd <- loadRData( file = file.path(firefolder, 'ESACCI-L3S_FIRE-BA-MODIS-AREA_2-fv5.1-JD-01-18.rda'))# fire day of year (doy)
min(dts)
max(dts)
dtsbr <- seq(min(dts), max(dts), by = "3 months")#"1 day"
min(dtsbr)
max(dtsbr)
st <- toRegularTS(dts, dts, fun='max', resol = 'quart')
min(tst)
min(st)
st
?ts
as.Date(st)
tempRes
tsfile
dtsbr <- as.Date(toRegularTS(dts, dts, fun='max', resol = tempRes))
dtsbr <- rollback(dtsbr, roll_to_first = TRUE, preserve_hms = TRUE)
dtsfr <- as.Date(toRegularTS(fdts, fdts, fun='max', resol = tempRes))
# date vector associated with the fire stack
fdts<- as.Date(names(fcl), format = "X%Y%m%d") # dates associated with the fire data stack
# get the dates of the nbr and fire stacks
dtsbr <- as.Date(toRegularTS(dts, dts, fun='max', resol = tempRes))
dtsbr <- rollback(dtsbr, roll_to_first = TRUE, preserve_hms = TRUE)
dtsfr <- as.Date(toRegularTS(fdts, fdts, fun='max', resol = tempRes))
dtsfr <- rollback(dtsfr, roll_to_first = TRUE, preserve_hms = TRUE)
save(dtsfr, file = file.path(ofolder, paste0(tsfile, '_Firedts_', tempRes)))
save(dtsbr, file = file.path(ofolder, paste0(tsfile, '_dts_', tempRes, '_', tempFun)))
library(UpscaleRecovery)
library(ggplot2)
library(raster)
library(rasterVis)
library(sp)
library(maps)
library(maptools)
library(ggmap)
library("ggplot2")
library("sf")
library('rgdal')
library(rnaturalearth)
library(rnaturalearthdata)
library("ggspatial")
library("RColorBrewer")
# folder where data is stored
ofolder <- 'C:\\Users\\keers001\\OneDrive - WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Data\\'
# base name of the recovery indicator files
basename <- c('LSTS_SantaRem_area', '_2000_2020_Stab_monthly_maxBreak_F_obspyr_12_inp_segmented_shortDenseTS_TRUE_nPre_2_nDist_12_nPostMin_4_nPostMax_6_h_15')
# directory where the figures will be stored
figfolder <- 'C:\\Users\\keers001\\OneDrive - WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Figures\\'
# lcfolder <- 'C:\\Users\\keers001\\OneDrive - WageningenUR\\RETURN\\Data\\RETURN\\CopernicusLandCover\\'
ste <- 2
stm <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_monthly_max.gri')))
frm <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_Fire_monthly.gri')))
stq <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_quart_max.gri')))
frq <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_Fire_quart.gri')))
dtsq <- loadRData(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_dts_quart_max')))
dtsq <- loadRData(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_dts_quart_max')))
stq
dtsfq <- loadRData(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_dtsfire_quart')))
dtsfq <- loadRData(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_Firedts_quart')))
frq
ifolder <- 'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Data\\' # directory with NBR data
ofolder <- 'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Data\\' # directory where the recovery indicators and temporary outputs will be saved
firefolder <- 'C:\\Users\\keers001\\OneDrive - WageningenUR\\RETURN\\Data\\RETURN\\CCI_fire\\' #'\\\\WURNET.NL\\Homes\\keers001\\AppData\\FolderRedirection\\Desktop\\cci_fire2\\'
# directory where the fire data are stored
tsfile <- 'LSTS_SantaRem_area2_2000_2020'# name of the file with NBR time series
metafile <- 'LSTS_meta_SantaRem_area2_2000_2020'# metadata file of the NBR time series
firefile <- 'LSTS_FireArea_SantaRem_area2_2000_2020'# name of the file with the fire mask
tempRes <- 'monthly' # daily, annual, monthly, or quart (yearly data not supported yet!)
tempFun <- 'max' # max or mean (function used for temporal aggregation of data)
timeThres <- 2 # in case of segmentations, the time period between the detected break and the disturbance should be less than timeThres years
slpThres <- 2 # the slope of the pre-disturbance period should be less than slpThres
# settings of the derived recovery indicators
# input: refers to the tine series pre-processing: raw (=no preprocessing), smoothed or segmented
# h: This parameter defines the minimal segment size either given as fraction relative to the sample size or as an integer giving the minimal number of observations in each segment.
# shortDenseTS: TRUE or FALSE. In case TRUE, the metrics are adjusted to be compatible with short, dense time series. In case FALSE, the input time series is assumed to have annual observations and at least 2 and 5 pre- and post-disturbance years, respectively.
# nPre: If shortDenseTS is TRUE, number of years prior to the disturbance used to calculate the pre-disturbance value
# nDist: If shortDenseTS is TRUE, number of months used to quantify the time series value during the disturbance
# nPostMin: If shortDenseTS is TRUE, min number of years after the disturbance used to quantify the recovery
# nPostMax: If shortDenseTS is TRUE, max number of years after the disturbance used to quantify the recovery
# tdist: the timing of the disturbance [observation number]
if((tempRes == 'monthly') || (tempRes == 'daily')){
funSet <- list('input' = c('raw', 'smoothed', 'segmented', 'raw', 'smoothed', 'segmented'),# settings for the recovery indicators
'shortDenseTS' = c( TRUE, TRUE, TRUE, TRUE, TRUE, TRUE),
'nPre' = c(2,2,2,2,2,2),
'nDist' = c(1,1,1,12,12,12),
'nPostMin' = c(0,0,0,4,4,4),
'nPostMax' = c(1,1,1,6,6,6),
'h' = c(0.15,0.15,0.15,0.15,0.15,0.15))
} else if (tempRes == 'annual'){
funSet <- list('input' = c('raw'),# settings for the recovery indicators
'shortDenseTS' = c( FALSE),
'nPre' = c(2),
'nDist' = c(12),
'nPostMin' = c(4),
'nPostMax' = c(6),
'h' = c(0.15))
}
br <- stack(paste0(ifolder,tsfile,'.tif'))# the data stack containing the vegetation response
br <- br[[-1]] # the first image is redundant, artefact from the GEE download script
meta <- read.csv(paste0(ifolder,metafile,'.csv'))# metadata associated with the image stack
dts <- as.Date(meta$system_time_start[-1],'%Y,%m,%d')# observation dates of the image stack
fre <- raster(paste0(ifolder,firefile,'.tif'))# raster of areas that experienced a fire (those have a value > 0)
fcl <- loadRData( file = file.path(firefolder, 'ESACCI-L3S_FIRE-BA-MODIS-AREA_2-fv5.1-CL-01-18.rda'))# fire confidence
fjd <- loadRData( file = file.path(firefolder, 'ESACCI-L3S_FIRE-BA-MODIS-AREA_2-fv5.1-JD-01-18.rda'))# fire day of year (doy)
# date vector associated with the fire stack
fdts<- as.Date(names(fcl), format = "X%Y%m%d") # dates associated with the fire data stack
dtsbr <- as.Date(toRegularTS(dts, dts, fun='max', resol = tempRes))
dtsbr <- rollback(dtsbr, roll_to_first = TRUE, preserve_hms = TRUE)
dtsfr <- as.Date(toRegularTS(fdts, fdts, fun='max', resol = tempRes))
dtsfr <- rollback(dtsfr, roll_to_first = TRUE, preserve_hms = TRUE)
save(dtsfr, file = file.path(ofolder, paste0(tsfile, '_Firedts_', tempRes)))
save(dtsbr, file = file.path(ofolder, paste0(tsfile, '_dts_', tempRes, '_', tempFun)))
#
ifolder <- 'C:\\Users\\keers001\\OneDrive\ -\ WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Data\\' # folder with data characteristics
firefolder <- 'C:\\Users\\keers001\\OneDrive - WageningenUR\\RETURN\\Data\\RETURN\\CCI_fire\\' #'\\\\WURNET.NL\\Homes\\keers001\\AppData\\FolderRedirection\\Desktop\\cci_fire2\\'
metafile <- 'LSTS_meta_SantaRem_area3_2000_2020'
meta <- read.csv(paste0(ifolder,metafile,'.csv'))# metadata associated with the image stack
dts <- as.Date(meta$system_time_start[-1],'%Y,%m,%d')# observation dates of the image stack
load( file = file.path(firefolder, 'ESACCI-L3S_FIRE-BA-MODIS-AREA_2-fv5.1-CL-01-18.rda'))# fire
fdts<- as.Date(names(clst), format = "X%Y%m%d") # dates associated with the fire data stack
library(lubridate)
dtsbr <- seq(min(dts), max(dts), by = "1 month")#"1 day"
dtsbr <- rollback(dtsbr, roll_to_first = TRUE, preserve_hms = TRUE)
dtsfr <- fdts
dtsfr <- rollback(dtsfr, roll_to_first = TRUE, preserve_hms = TRUE)
# folder where data is stored
ofolder <- 'C:\\Users\\keers001\\OneDrive - WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Data\\'
# base name of the recovery indicator files
basename <- c('LSTS_SantaRem_area', '_2000_2020_Stab_monthly_maxBreak_F_obspyr_12_inp_segmented_shortDenseTS_TRUE_nPre_2_nDist_12_nPostMin_4_nPostMax_6_h_15')
# directory where the figures will be stored
figfolder <- 'C:\\Users\\keers001\\OneDrive - WageningenUR\\RETURN\\Data\\RETURN\\20200107_Upscaling\\CaseStudy\\Figures\\'
# lcfolder <- 'C:\\Users\\keers001\\OneDrive - WageningenUR\\RETURN\\Data\\RETURN\\CopernicusLandCover\\'
ste <- 2
stm <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_monthly_max.gri')))
frm <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_Fire_monthly.gri')))
dtsm <- loadRData(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_dts_monthly_max')))
dtsfm <- loadRData(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_Firedts_monthly')))
stq <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_quart_max.gri')))
frq <- stack(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_Fire_quart.gri')))
dtsq <- loadRData(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_dts_quart_max')))
dtsfq <- loadRData(file.path(ofolder, paste0('LSTS_SantaRem_area',ste,'_2000_2020_Firedts_quart')))
frm
frq
stm
stq
dtsm
stab <- stack(file.path(ofolder, paste0(basename[1],ste, basename[2],'.gri')))
si <- 1
qu <- as.numeric(quantile(stab[[si]] , probs = c(0.001,0.25,0.5,0.75,0.999), na.rm = T))
tsmii <- matrix(NA,5,dim(stm)[3])
frmii <- matrix(NA,5,dim(frm)[3])
trmii <- matrix(NA,5,dim(stm)[3])
tsqii <- matrix(NA,5,dim(stq)[3])
frqii <- matrix(NA,5,dim(frq)[3])
trqii <- matrix(NA,5,dim(stq)[3])
startdt <- max(c(min(dtsm), min(dtsfm)))
enddt  <- min(c(max(dtsm), max(dtsfm)))
dtsst <- seq(startdt, enddt, by = "1 month")#"1 day"
# clip the stacks to the overlap period
indbr  <- which((dtsm > (startdt-1)) & (dtsm < (enddt+1)))
indfr  <- which((dtsfm > (startdt-1)) & (dtsfm < (enddt+1)))
stm <- st[[indbr]]
stm <- stm[[indbr]]
frm <- frm[[indfr]]
startdt <- max(c(min(dtsq), min(dtsfq)))
enddt  <- min(c(max(dtsq), max(dtsfq)))
dtsst <- seq(startdt, enddt, by = "1 month")#"1 day"
# clip the stacks to the overlap period
indbr  <- which((dtsq > (startdt-1)) & (dtsq < (enddt+1)))
indfr  <- which((dtsfq > (startdt-1)) & (dtsfq < (enddt+1)))
stq <- stq[[indbr]]
frq <- frq[[indfr]]
qu <- as.numeric(quantile(stab[[si]] , probs = c(0.001,0.25,0.5,0.75,0.999), na.rm = T))
tsmii <- matrix(NA,5,dim(stm)[3])
frmii <- matrix(NA,5,dim(frm)[3])
trmii <- matrix(NA,5,dim(stm)[3])
tsqii <- matrix(NA,5,dim(stq)[3])
frqii <- matrix(NA,5,dim(frq)[3])
trqii <- matrix(NA,5,dim(stq)[3])
for (ii in 1:5){# levels of the recovery index
minind <- Which(abs(stab[[si]] - qu[ii]) == minValue(abs(stab[[si]] - qu[ii])), cells=T)
tsmii[ii,] <- as.numeric(stm[minind[1]])
frmii[ii,] <- as.numeric(frm[minind[1]])
tmp <- ts(tsmii[ii,], frequency = 12)
datapp <- bfastpp(tmp, order = 1, lag = NULL, slag = NULL,
na.action = na.omit, stl = 'none')
bp <- breakpoints(response ~ trend, data = datapp, h = 0.15)
# Extract BFAST trend component and breaks
cf <- coef(bp)
tbp <- bp$breakpoints #observation number of break
indna <- which(is.na(tmp)==F)
tbp <- indna[tbp]   # correct observation number for missing values
#Derive trend component without missing values
bpf <- c(0, tbp, length(tmp))
trf <- rep(NA,length(tmp))
for(ti in 1:(length(bpf)-1)){
trf[(bpf[ti]+1):bpf[ti+1]] <- cf[ti,1] + ((cf[ti,2]*((bpf[ti]+1):bpf[ti+1])))
}
trmii[ii,] <- trf
tsqii[ii,] <- as.numeric(stq[minind[1]])
frqii[ii,] <- as.numeric(frq[minind[1]])
tmp <- ts(tsqii[ii,], frequency = 12)
datapp <- bfastpp(tmp, order = 1, lag = NULL, slag = NULL,
na.action = na.omit, stl = 'none')
bp <- breakpoints(response ~ trend, data = datapp, h = 0.15)
# Extract BFAST trend component and breaks
cf <- coef(bp)
tbp <- bp$breakpoints #observation number of break
indna <- which(is.na(tmp)==F)
tbp <- indna[tbp]   # correct observation number for missing values
#Derive trend component without missing values
bpf <- c(0, tbp, length(tmp))
trf <- rep(NA,length(tmp))
for(ti in 1:(length(bpf)-1)){
trf[(bpf[ti]+1):bpf[ti+1]] <- cf[ti,1] + ((cf[ti,2]*((bpf[ti]+1):bpf[ti+1])))
}
trqii[ii,] <- trf
}
for (ii in 1:5){# levels of the recovery index
minind <- Which(abs(stab[[si]] - qu[ii]) == minValue(abs(stab[[si]] - qu[ii])), cells=T)
tsmii[ii,] <- as.numeric(stm[minind[1]])
frmii[ii,] <- as.numeric(frm[minind[1]])
tmp <- ts(tsmii[ii,], frequency = 12)
datapp <- bfastpp(tmp, order = 1, lag = NULL, slag = NULL,
na.action = na.omit, stl = 'none')
bp <- breakpoints(response ~ trend, data = datapp, h = 0.15)
# Extract BFAST trend component and breaks
cf <- coef(bp)
tbp <- bp$breakpoints #observation number of break
indna <- which(is.na(tmp)==F)
tbp <- indna[tbp]   # correct observation number for missing values
#Derive trend component without missing values
bpf <- c(0, tbp, length(tmp))
trf <- rep(NA,length(tmp))
for(ti in 1:(length(bpf)-1)){
trf[(bpf[ti]+1):bpf[ti+1]] <- cf[ti,1] + ((cf[ti,2]*((bpf[ti]+1):bpf[ti+1])))
}
trmii[ii,] <- trf
tsqii[ii,] <- as.numeric(stq[minind[1]])
frqii[ii,] <- as.numeric(frq[minind[1]])
tmp <- ts(tsqii[ii,], frequency = 4)
datapp <- bfastpp(tmp, order = 1, lag = NULL, slag = NULL,
na.action = na.omit, stl = 'none')
bp <- breakpoints(response ~ trend, data = datapp, h = 0.15)
# Extract BFAST trend component and breaks
cf <- coef(bp)
tbp <- bp$breakpoints #observation number of break
indna <- which(is.na(tmp)==F)
tbp <- indna[tbp]   # correct observation number for missing values
#Derive trend component without missing values
bpf <- c(0, tbp, length(tmp))
trf <- rep(NA,length(tmp))
for(ti in 1:(length(bpf)-1)){
trf[(bpf[ti]+1):bpf[ti+1]] <- cf[ti,1] + ((cf[ti,2]*((bpf[ti]+1):bpf[ti+1])))
}
trqii[ii,] <- trf
}
ii
trmii[ii,]
frqii[ii,]
tmp <- ts(tsqii[ii,], frequency = 4)
datapp <- bfastpp(tmp, order = 1, lag = NULL, slag = NULL,
na.action = na.omit, stl = 'none')
bp <- breakpoints(response ~ trend, data = datapp, h = 0.15)
# Extract BFAST trend component and breaks
cf <- coef(bp)
tbp <- bp$breakpoints #observation number of break
indna <- which(is.na(tmp)==F)
tbp <- indna[tbp]   # correct observation number for missing values
#Derive trend component without missing values
bpf <- c(0, tbp, length(tmp))
trf <- rep(NA,length(tmp))
for(ti in 1:(length(bpf)-1)){
trf[(bpf[ti]+1):bpf[ti+1]] <- cf[ti,1] + ((cf[ti,2]*((bpf[ti]+1):bpf[ti+1])))
}
trqii[ii,] <- trf
trqii[ii,]
for (ii in 1:5){# levels of the recovery index
minind <- Which(abs(stab[[si]] - qu[ii]) == minValue(abs(stab[[si]] - qu[ii])), cells=T)
tsmii[ii,] <- as.numeric(stm[minind[1]])
frmii[ii,] <- as.numeric(frm[minind[1]])
tmp <- ts(tsmii[ii,], frequency = 12)
datapp <- bfastpp(tmp, order = 1, lag = NULL, slag = NULL,
na.action = na.omit, stl = 'none')
bp <- breakpoints(response ~ trend, data = datapp, h = 0.15)
# Extract BFAST trend component and breaks
cf <- coef(bp)
tbp <- bp$breakpoints #observation number of break
indna <- which(is.na(tmp)==F)
tbp <- indna[tbp]   # correct observation number for missing values
#Derive trend component without missing values
bpf <- c(0, tbp, length(tmp))
trf <- rep(NA,length(tmp))
for(ti in 1:(length(bpf)-1)){
trf[(bpf[ti]+1):bpf[ti+1]] <- cf[ti,1] + ((cf[ti,2]*((bpf[ti]+1):bpf[ti+1])))
}
trmii[ii,] <- trf
tsqii[ii,] <- as.numeric(stq[minind[1]])
# frqii[ii,] <- as.numeric(frq[minind[1]])
tmp <- ts(tsqii[ii,], frequency = 4)
datapp <- bfastpp(tmp, order = 1, lag = NULL, slag = NULL,
na.action = na.omit, stl = 'none')
bp <- breakpoints(response ~ trend, data = datapp, h = 0.15)
# Extract BFAST trend component and breaks
cf <- coef(bp)
tbp <- bp$breakpoints #observation number of break
indna <- which(is.na(tmp)==F)
tbp <- indna[tbp]   # correct observation number for missing values
#Derive trend component without missing values
bpf <- c(0, tbp, length(tmp))
trf <- rep(NA,length(tmp))
for(ti in 1:(length(bpf)-1)){
trf[(bpf[ti]+1):bpf[ti+1]] <- cf[ti,1] + ((cf[ti,2]*((bpf[ti]+1):bpf[ti+1])))
}
trqii[ii,] <- trf
}
ii
plot(zoo(tsmii,dsm))
plot(zoo(tsmii,dtsm))
tsmii
plot(zoo(tsmii[1,],dtsm))
plot(zoo(tsmii[1,],dtsm))
lines(zoo(trqii[i,],dtsm))
plot(zoo(tsmii[1,],dtsm))
lines(zoo(trqii[1,],dtsm))
lines(zoo(trqii[1,],dtsm), col = 'red')
plot(zoo(tsmii[1,],dtsm))
lines(zoo(trqii[1,],dtsm), col = 'red')
plot(zoo(tsmii[1,],dtsm))
lines(zoo(trmii[1,],dtsm), col = 'red')
lines(zoo(tsqii[1,],dtsq), col = 'green', lt = 'o')
plot(zoo(tsmii[1,],dtsm))
lines(zoo(trmii[1,],dtsm), col = 'red')
lines(zoo(tsqii[1,],dtsq), col = 'green', lt = 'o')
plot(zoo(tsmii[1,],dtsm))
lines(zoo(trmii[1,],dtsm), col = 'red')
lines(zoo(tsqii[1,],dtsq), col = 'green', type = 'o')
plot(zoo(tsmii[1,],dtsm), type = 'o')
lines(zoo(trmii[1,],dtsm), col = 'red')
lines(zoo(tsqii[1,],dtsq), col = 'green', type = 'o')
plot(zoo(tsmii[1,],dtsm), type = 'o')
lines(zoo(trmii[1,],dtsm), col = 'red')
lines(zoo(tsqii[1,],dtsq), col = 'green', type = 'o')
lines(zoo(trqii[1,],dtsq), col = 'blue')
# Necessary packages and functions.
library("codetools")
library("parallel")
library("coda") # Otherwise error when loading bamlss
library("colorspace") # Otherwise error when loading bamlss
library("nlme") # Otherwise error when loading mgcv
library("mgcv") # Otherwise error when loading bamlss
library("Matrix") # Otherwise error when loading tvReg
library("plm") # Otherwise error when loading tvReg
library("iterators") # Otherwise error when loading doParallel
library("sp") # Otherwise error when loading doParallel
library("bamlss")
library("raster")
library("zoo")
library("crayon") # Otherwise error when loading tvReg
library("tvReg")
library("foreach")
library("doParallel")
library("snow")
library("rgdal")
library("imguR")
library(pbapply)
################
#### Set-up ####
################
# Load the NDVI data.
ndvi_crop <- stack("/home/wanda/Desktop/ndvi_crop.tif")
###################
#### Functions ####
###################
get_signals <- function(x) {
if(mean(is.na(x)) > 0.1) {
rval <- matrix(NA, nrow = length(x), ncol = 4)
colnames(rval) <- c("trend", "sigma", "alpha", "residuals")
} else {
x <- ts(as.numeric(x), start = c(2000, 2), freq = 12)
dx <- abs(diff(x)/x[-1])
x[c(FALSE, dx > 0.5)] <- NA
x <- log(na.approx(x, rule = 2))
d <- data.frame(
response = as.numeric(x),
trend = 1:length(x),
season = cycle(x)
)
f <- list(
response ~ ti(trend,k=20) + ti(season,bs="cc",k=10) +
ti(trend,season,bs=c("cr","cc")),
sigma ~ ti(trend,k=20) + ti(season,bs="cc",k=10) +
ti(trend,season,bs=c("cr","cc")),
alpha ~ ti(trend,k=20) + ti(season,bs="cc",k=10) +
ti(trend,season,bs=c("cr","cc"))
)
b <- try(bamlss(f, data = d,
family = gF("AR1", mu = TRUE),
knots = list("season" = c(0, 12)),
results = FALSE, eps = 0.001, verbose = FALSE),
silent = TRUE)
if(inherits(b, "try-error")) {
rval <- matrix(NA, nrow = length(x), ncol = 4)
colnames(rval) <- c("trend", "sigma", "alpha", "residuals")
} else {
alpha <- predict(b, model = "alpha", type = "parameter", term = "ti(trend)")
sigma <- predict(b, model = "sigma", type = "parameter", term = "ti(trend)")
trend <- predict(b, model = "mu", type = "parameter", term = "ti(trend)")
mu <- predict(b, model = "mu", type = "parameter")
e <- d$response - mu
e1 <- c(0, e[-length(e)])
mu <- mu + alpha * e1
res <- d$response - mu
rval <- cbind(
"trend" = trend,
"sigma" = sigma,
"alpha" = alpha,
"residuals" = res
)
}
}
return(rval)
}
# helper function of get_signals_mat and get_signals_par
get_signals_v <- function(x){
out <- get_signals(x)
return(as.numeric(c(out[,1], out[,2], out[,3], out[4])))
}
# get signals for a matrix of time series
get_signals_mat <- function(x){
out <- apply(x,1,function(i){
get_signals_v(i)
})
t(out)
}
# get signals for a matrix of time series using parallel computing
get_signals_par <- function(x){
no_cores <- detectCores() - 1# Define the number of cores
cl <- makeCluster(no_cores)
clusterCall(cl, function() library(bamlss))
clusterCall(cl, function() library(zoo))
clusterCall(cl, function() library(tvReg))
clusterCall(cl, function() library(codetools))
clusterCall(cl, function() library(imguR))
clusterExport(cl, c("na.approx",'get_signals_v', 'get_signals'))
out <- pbapply(x,1,function(i){get_signals_v(i)}, cl = cl)
endCluster()
t(out)
}
knitr::opts_chunk$set(echo = TRUE, eval=F)
library(raster)
# library(ff)
library(UpscaleRecovery)
install()
library(devtools)
install()
library(raster)
# library(ff)
library(UpscaleRecovery)
library(stars)
forcefolder <- '/home/wanda/Documents/data/force/'
